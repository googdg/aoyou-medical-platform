<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¦å…‹å¤§æˆ˜ç»å…¸ç‰ˆ - Tank Battle Classic</title>
    <meta name="description" content="ç»å…¸å¦å…‹å¤§æˆ˜æ¸¸æˆï¼Œé‡ç°ç«¥å¹´å›å¿†ï¼æ”¯æŒå•äººé—¯å…³å’ŒåŒäººå¯¹æˆ˜æ¨¡å¼ã€‚">
    
    <!-- ç¤¾äº¤åª’ä½“åˆ†äº«ä¼˜åŒ– -->
    <meta property="og:title" content="å¦å…‹å¤§æˆ˜ç»å…¸ç‰ˆ - ç«¥å¹´ç»å…¸æ¸¸æˆ">
    <meta property="og:description" content="é‡ç°ç»å…¸FCå¦å…‹å¤§æˆ˜ï¼Œæ”¯æŒå•äººé—¯å…³å’ŒåŒäººå¯¹æˆ˜ï¼">
    <meta property="og:type" content="website">
    
    <!-- PWAæ”¯æŒ -->
    <meta name="theme-color" content="#2C3E50">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="å¦å…‹å¤§æˆ˜">
    
    <!-- å›¾æ ‡ -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸš—</text></svg>">
    
    <style>
        /* åŸºç¡€æ ·å¼é‡ç½® */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #2C3E50 0%, #34495E 50%, #2C3E50 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
        }

        /* æ¸¸æˆå®¹å™¨ */
        .game-container {
            position: relative;
            background: #000;
            border: 4px solid #333;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        /* æ¸¸æˆç”»å¸ƒ */
        #gameCanvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* æ¸¸æˆç•Œé¢è¦†ç›–å±‚ */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }

        /* æ¸¸æˆä¿¡æ¯é¢æ¿ */
        .game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #FFD700;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: auto;
        }

        .info-left, .info-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 15px;
            border: 2px solid #FFD700;
        }

        /* æ¸¸æˆèœå• */
        .game-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(44, 62, 80, 0.95) 100%);
            color: white;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            border: 3px solid #FFD700;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .game-menu h1 {
            color: #FFD700;
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .game-menu h2 {
            color: #FFD700;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .game-menu p {
            margin-bottom: 30px;
            font-size: 16px;
            line-height: 1.6;
            opacity: 0.9;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .menu-btn {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            min-width: 200px;
        }

        .menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
        }

        .menu-btn:active {
            transform: translateY(-1px);
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #95A5A6 0%, #7F8C8D 100%);
            color: white;
        }

        /* æ§åˆ¶è¯´æ˜ */
        .controls-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            color: #FFD700;
            font-size: 12px;
            text-align: center;
            opacity: 0.8;
            pointer-events: auto;
        }

        .controls-row {
            display: flex;
            justify-content: space-around;
            margin-bottom: 5px;
        }

        /* æš‚åœç•Œé¢ */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
            pointer-events: auto;
        }

        .pause-menu {
            background: rgba(44, 62, 80, 0.95);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #FFD700;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .game-container {
                border: 2px solid #333;
            }

            .game-info {
                font-size: 14px;
                top: 5px;
                left: 5px;
                right: 5px;
            }

            .info-left, .info-right {
                gap: 10px;
            }

            .info-item {
                padding: 3px 8px;
                font-size: 12px;
            }

            .game-menu {
                padding: 30px 40px;
                margin: 0 20px;
            }

            .game-menu h1 {
                font-size: 24px;
            }

            .game-menu h2 {
                font-size: 20px;
            }

            .controls-info {
                font-size: 10px;
                bottom: 5px;
            }
        }

        @media (max-width: 480px) {
            .game-menu {
                padding: 20px 30px;
            }

            .menu-btn {
                padding: 12px 24px;
                font-size: 14px;
                min-width: 160px;
            }

            .info-left, .info-right {
                flex-direction: column;
                gap: 5px;
            }
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 18px;
            z-index: 300;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #FFD700;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* éšè—ç±» */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- æ¸¸æˆç”»å¸ƒ -->
        <canvas id="gameCanvas" width="832" height="624"></canvas>
        
        <!-- æ¸¸æˆç•Œé¢è¦†ç›–å±‚ -->
        <div class="game-overlay">
            <!-- æ¸¸æˆä¿¡æ¯é¢æ¿ -->
            <div class="game-info">
                <div class="info-left">
                    <div class="info-item">
                        <span>ğŸš—</span>
                        <span id="player1Lives">3</span>
                    </div>
                    <div class="info-item">
                        <span>ğŸ†</span>
                        <span id="score">0</span>
                    </div>
                    <div class="info-item">
                        <span>ğŸ¯</span>
                        <span id="level">1</span>
                    </div>
                </div>
                <div class="info-right">
                    <div class="info-item">
                        <span>ğŸ¤–</span>
                        <span id="enemyCount">20</span>
                    </div>
                    <div class="info-item">
                        <span>â±ï¸</span>
                        <span id="gameTime">00:00</span>
                    </div>
                    <div class="info-item" id="player2Info" style="display: none;">
                        <span>ğŸš™</span>
                        <span id="player2Lives">3</span>
                    </div>
                </div>
            </div>

            <!-- æ§åˆ¶è¯´æ˜ -->
            <div class="controls-info">
                <div class="controls-row">
                    <span>ç©å®¶1: WASDç§»åŠ¨ ç©ºæ ¼å°„å‡»</span>
                    <span>ç©å®¶2: æ–¹å‘é”®ç§»åŠ¨ å›è½¦å°„å‡»</span>
                </div>
                <div class="controls-row">
                    <span>Pé”®æš‚åœ | Ré”®é‡æ–°å¼€å§‹ | ESCé”®è¿”å›èœå•</span>
                </div>
            </div>
        </div>

        <!-- ä¸»èœå• -->
        <div class="game-menu" id="mainMenu">
            <h1>ğŸš— å¦å…‹å¤§æˆ˜ç»å…¸ç‰ˆ</h1>
            <p>
                é‡ç°ç»å…¸FCå¦å…‹å¤§æˆ˜æ¸¸æˆï¼<br><br>
                ğŸ¯ <strong>å•äººæ¨¡å¼</strong>ï¼šæŒ‘æˆ˜20ä¸ªç²¾å¿ƒè®¾è®¡çš„å…³å¡<br>
                ğŸ‘¥ <strong>åŒäººæ¨¡å¼</strong>ï¼šä¸æœ‹å‹ä¸€èµ·å¹¶è‚©ä½œæˆ˜<br>
                ğŸ† <strong>ç»å…¸ç©æ³•</strong>ï¼šåŸæ±åŸå‘³çš„æ¸¸æˆä½“éªŒ<br>
                ğŸ® <strong>ç®€å•æ“ä½œ</strong>ï¼šæ˜“ä¸Šæ‰‹ï¼Œéš¾ç²¾é€š
            </p>
            <div class="menu-buttons">
                <button class="menu-btn" onclick="startSinglePlayer()">ğŸ¯ å•äººæ¸¸æˆ</button>
                <button class="menu-btn" onclick="startTwoPlayer()">ğŸ‘¥ åŒäººæ¸¸æˆ</button>
                <button class="menu-btn secondary" onclick="showSettings()">âš™ï¸ æ¸¸æˆè®¾ç½®</button>
                <button class="menu-btn secondary" onclick="showHelp()">â“ æ¸¸æˆå¸®åŠ©</button>
            </div>
        </div>

        <!-- æš‚åœèœå• -->
        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-menu">
                <h2>â¸ï¸ æ¸¸æˆæš‚åœ</h2>
                <div class="menu-buttons">
                    <button class="menu-btn" onclick="resumeGame()">â–¶ï¸ ç»§ç»­æ¸¸æˆ</button>
                    <button class="menu-btn secondary" onclick="restartGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
                    <button class="menu-btn secondary" onclick="backToMenu()">ğŸ  è¿”å›ä¸»èœå•</button>
                </div>
            </div>
        </div>

        <!-- åŠ è½½æç¤º -->
        <div class="loading hidden" id="loadingIndicator">
            æ­£åœ¨åŠ è½½æ¸¸æˆèµ„æº...
        </div>
    </div>

    <!-- å¼•å…¥å®ä½“ç»„ä»¶ç³»ç»Ÿ -->
    <script src="js/entity-component-system.js"></script>
    <!-- å¼•å…¥åœ°å›¾ç³»ç»Ÿ -->
    <script src="js/map-system.js"></script>
    <!-- å¼•å…¥å¦å…‹ç³»ç»Ÿ -->
    <script src="js/tank-system.js"></script>
    <!-- å¼•å…¥å­å¼¹ç³»ç»Ÿ -->
    <script src="js/bullet-system.js"></script>
    <!-- å¼•å…¥AIç³»ç»Ÿ -->
    <script src="js/ai-system.js"></script>
    <!-- å¼•å…¥é«˜çº§AIç³»ç»Ÿ -->
    <script src="js/advanced-ai-system.js"></script>
    <!-- å¼•å…¥é“å…·ç³»ç»Ÿ -->
    <script src="js/powerup-system.js"></script>
    <!-- å¼•å…¥å¾—åˆ†ç³»ç»Ÿ -->
    <script src="js/score-system.js"></script>
    <!-- å¼•å…¥å…³å¡ç³»ç»Ÿ -->
    <script src="js/level-system.js"></script>
    <!-- å¼•å…¥éŸ³é¢‘ç³»ç»Ÿ -->
    <script src="js/audio-system.js"></script>
    <!-- å¼•å…¥æˆ˜æ–—ç³»ç»Ÿ -->
    <script src="js/combat-system.js"></script>
    
    <script>
        // æ¸¸æˆå¼•æ“æ ¸å¿ƒç±»
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = 'MENU'; // MENU, PLAYING, PAUSED, GAME_OVER
                this.gameMode = 'SINGLE'; // SINGLE, DOUBLE
                this.lastTime = 0;
                this.deltaTime = 0;
                this.fps = 60;
                this.targetFrameTime = 1000 / this.fps;
                
                // æ¸¸æˆå¯¹è±¡
                this.currentScene = null;
                this.inputManager = new InputManager();
                this.audioManager = new AudioManager();
                this.assetManager = new AssetManager();
                
                // å®ä½“ç»„ä»¶ç³»ç»Ÿ
                this.entityManager = new ECS.EntityManager();
                this.collisionSystem = new ECS.CollisionSystem(this.entityManager);
                
                // åœ°å›¾ç³»ç»Ÿ
                this.mapManager = new MapSystem.MapManager();
                this.currentMap = null;
                
                // å¦å…‹ç³»ç»Ÿ
                this.tankManager = new TankSystem.TankManager(this.entityManager);
                
                // å°„å‡»ç³»ç»Ÿ
                this.fireSystem = new BulletSystem.FireSystem();
                
                // AIç³»ç»Ÿ
                this.aiManager = new AISystem.AIManager(this.entityManager);
                
                // æˆ˜æ–—ç³»ç»Ÿ
                this.combatManager = new CombatSystem.CombatManager(this.entityManager);
                this.damageNumberSystem = new CombatSystem.DamageNumberSystem();
                
                // é“å…·ç³»ç»Ÿ
                this.powerUpManager = null; // å°†åœ¨åœ°å›¾åŠ è½½ååˆå§‹åŒ–
                this.weaponUpgradeSystem = new PowerUpSystem.WeaponUpgradeSystem();
                
                // å¾—åˆ†å’Œç”Ÿå‘½å€¼ç³»ç»Ÿ
                this.scoreComponent = new ScoreSystem.ScoreComponent();
                this.gameStateManager = new ScoreSystem.GameStateManager();
                this.playerLifeSystem = new ScoreSystem.LifeSystem(3, 3000);
                
                // å…³å¡ç³»ç»Ÿ
                this.levelManager = new LevelSystem.LevelManager();
                
                // éŸ³é¢‘ç³»ç»Ÿ
                this.audioManager = new AudioSystem.AudioManager();
                
                // è®¾ç½®æˆ˜æ–—äº‹ä»¶ç›‘å¬å™¨
                this.setupCombatEventListeners();
                
                // æ¸¸æˆæ•°æ®
                this.gameData = {
                    score: 0,
                    level: 1,
                    lives: 3,
                    enemyCount: 20,
                    gameTime: 0,
                    player1Lives: 3,
                    player2Lives: 3
                };
                
                this.init();
            }

            async init() {
                console.log('ğŸ® åˆå§‹åŒ–å¦å…‹å¤§æˆ˜æ¸¸æˆå¼•æ“...');
                
                // æ˜¾ç¤ºåŠ è½½æç¤º
                this.showLoading(true);
                
                try {
                    // åˆå§‹åŒ–å„ä¸ªç³»ç»Ÿ
                    await this.assetManager.loadAssets();
                    await this.audioManager.initialize();
                    this.inputManager.init();
                    this.audioManager.init();
                    
                    // è®¾ç½®Canvas
                    this.setupCanvas();
                    
                    // å¼€å§‹æ¸¸æˆå¾ªç¯
                    this.startGameLoop();
                    
                    console.log('âœ… æ¸¸æˆå¼•æ“åˆå§‹åŒ–å®Œæˆ');
                    
                } catch (error) {
                    console.error('âŒ æ¸¸æˆå¼•æ“åˆå§‹åŒ–å¤±è´¥:', error);
                } finally {
                    this.showLoading(false);
                }
            }

            setupCanvas() {
                // è®¾ç½®Canvasæ ·å¼å’Œå±æ€§
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'top';
                
                // æ¸…ç©ºç”»å¸ƒ
                this.clearCanvas();
                
                console.log('ğŸ–¼ï¸ Canvasè®¾ç½®å®Œæˆ');
            }

            startGameLoop() {
                console.log('ğŸ”„ å¯åŠ¨æ¸¸æˆä¸»å¾ªç¯');
                this.gameLoop();
            }

            gameLoop(currentTime = 0) {
                // è®¡ç®—æ—¶é—´å·®
                this.deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                // é™åˆ¶å¸§ç‡
                if (this.deltaTime >= this.targetFrameTime) {
                    this.update(this.deltaTime);
                    this.render();
                }
                
                // ç»§ç»­å¾ªç¯
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            update(deltaTime) {
                // æ›´æ–°è¾“å…¥
                this.inputManager.update();
                
                // æ ¹æ®æ¸¸æˆçŠ¶æ€æ›´æ–°
                switch (this.gameState) {
                    case 'MENU':
                        this.updateMenu(deltaTime);
                        break;
                    case 'PLAYING':
                        this.updateGame(deltaTime);
                        break;
                    case 'PAUSED':
                        this.updatePause(deltaTime);
                        break;
                    case 'GAME_OVER':
                        this.updateGameOver(deltaTime);
                        break;
                }
            }

            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.clearCanvas();
                
                // æ ¹æ®æ¸¸æˆçŠ¶æ€æ¸²æŸ“
                switch (this.gameState) {
                    case 'MENU':
                        this.renderMenu();
                        break;
                    case 'PLAYING':
                        this.renderGame();
                        break;
                    case 'PAUSED':
                        this.renderGame(); // ç»§ç»­æ˜¾ç¤ºæ¸¸æˆç”»é¢
                        break;
                    case 'GAME_OVER':
                        this.renderGameOver();
                        break;
                }
            }

            clearCanvas() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            updateMenu(deltaTime) {
                // èœå•çŠ¶æ€æ›´æ–°é€»è¾‘
                // è¿™é‡Œå¯ä»¥æ·»åŠ èœå•åŠ¨ç”»ç­‰
            }

            updateGame(deltaTime) {
                // å¤„ç†è¾“å…¥æ§åˆ¶
                this.handleGameInput();
                
                // æ›´æ–°å®ä½“ç®¡ç†å™¨
                this.entityManager.update(deltaTime);
                
                // æ›´æ–°å°„å‡»ç³»ç»Ÿ
                this.fireSystem.update(deltaTime);
                
                // æ›´æ–°AIç³»ç»Ÿ
                this.aiManager.update(deltaTime);
                
                // æ›´æ–°é“å…·ç³»ç»Ÿ
                if (this.powerUpManager) {
                    this.powerUpManager.update(deltaTime);
                }
                
                // æ›´æ–°å¾—åˆ†å’Œç”Ÿå‘½å€¼ç³»ç»Ÿ
                this.scoreComponent.update(deltaTime);
                this.playerLifeSystem.update(deltaTime);
                
                // æ›´æ–°æˆ˜æ–—ç³»ç»Ÿï¼ˆæ›¿ä»£åŸæ¥çš„ç¢°æ’ç³»ç»Ÿï¼‰
                this.combatManager.update(deltaTime);
                
                // æ›´æ–°ä¼¤å®³æ•°å­—ç³»ç»Ÿ
                this.damageNumberSystem.update(deltaTime);
                
                // æ¸¸æˆçŠ¶æ€æ›´æ–°é€»è¾‘
                if (this.currentScene) {
                    this.currentScene.update(deltaTime);
                }
                
                // æ›´æ–°æ¸¸æˆæ—¶é—´
                this.gameData.gameTime += deltaTime;
                this.updateUI();
            }

            // å¤„ç†æ¸¸æˆè¾“å…¥
            handleGameInput() {
                // è¾“å…¥ç°åœ¨ç”±TankControllerç»„ä»¶å¤„ç†
                // è¿™é‡Œå¯ä»¥å¤„ç†ä¸€äº›å…¨å±€è¾“å…¥ï¼Œå¦‚æš‚åœã€èœå•ç­‰
            }

            updatePause(deltaTime) {
                // æš‚åœçŠ¶æ€æ›´æ–°é€»è¾‘
                // æš‚åœæ—¶ä¸æ›´æ–°æ¸¸æˆé€»è¾‘
            }

            updateGameOver(deltaTime) {
                // æ¸¸æˆç»“æŸçŠ¶æ€æ›´æ–°é€»è¾‘
            }

            renderMenu() {
                // æ¸²æŸ“èœå•èƒŒæ™¯
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶æ ‡é¢˜èƒŒæ™¯å›¾æ¡ˆ
                this.drawMenuBackground();
            }

            renderGame() {
                // æ¸²æŸ“åœ°å›¾
                if (this.currentMap) {
                    this.currentMap.render(this.ctx);
                }
                
                // æ¸²æŸ“æ‰€æœ‰å®ä½“
                this.entityManager.render(this.ctx);
                
                // æ¸²æŸ“ä¼¤å®³æ•°å­—
                this.damageNumberSystem.render(this.ctx);
                
                // æ¸²æŸ“æ¸¸æˆåœºæ™¯
                if (this.currentScene) {
                    this.currentScene.render(this.ctx);
                } else {
                    // ä¸´æ—¶æ¸²æŸ“ä¸€äº›æµ‹è¯•å†…å®¹
                    this.drawTestContent();
                }
            }

            renderGameOver() {
                // æ¸²æŸ“æ¸¸æˆç»“æŸç”»é¢
                this.ctx.fillStyle = '#2a2a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawMenuBackground() {
                // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                const gridSize = 32;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawTestContent() {
                // ç»˜åˆ¶æµ‹è¯•å†…å®¹
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = '18px Arial';
                this.ctx.fillText('å¦å…‹å¤§æˆ˜ - å®Œæ•´ç³»ç»Ÿæµ‹è¯•', 50, 50);
                
                this.ctx.fillStyle = '#FFF';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`FPS: ${Math.round(1000 / this.deltaTime)}`, 50, 80);
                this.ctx.fillText(`æ¸¸æˆçŠ¶æ€: ${this.gameState}`, 50, 100);
                this.ctx.fillText(`æ¸¸æˆæ¨¡å¼: ${this.gameMode}`, 50, 120);
                this.ctx.fillText(`å®ä½“æ•°é‡: ${this.entityManager.getEntityCount()}`, 50, 140);
                
                if (this.currentMap) {
                    this.ctx.fillText(`åœ°å›¾: ${this.currentMap.width}x${this.currentMap.height}`, 50, 160);
                }
                
                if (this.tankManager) {
                    const stats = this.tankManager.getStats();
                    this.ctx.fillText(`ç©å®¶å¦å…‹: ${stats.alivePlayers}/${stats.totalPlayers}`, 50, 180);
                    this.ctx.fillText(`æ•Œæ–¹å¦å…‹: ${stats.aliveEnemies}/${stats.totalEnemies}`, 50, 200);
                }
                
                if (this.fireSystem) {
                    const fireStats = this.fireSystem.getStats();
                    this.ctx.fillText(`å­å¼¹: ${fireStats.activeBullets} (æ± : ${fireStats.pooledBullets})`, 50, 220);
                }
                
                const explosions = this.entityManager.getEntitiesByTag('explosion');
                this.ctx.fillText(`çˆ†ç‚¸æ•ˆæœ: ${explosions.length}`, 50, 240);
                
                if (this.aiManager) {
                    const aiStats = this.aiManager.getStats();
                    this.ctx.fillText(`AIå®ä½“: ${aiStats.totalAI}`, 50, 260);
                }
                
                if (this.combatManager) {
                    const combatStats = this.combatManager.getStats();
                    this.ctx.fillText(`æ€»ä¼¤å®³: ${combatStats.totalDamageDealt}`, 50, 280);
                    this.ctx.fillText(`å‡»ä¸­: ${combatStats.bulletsHit} ç¢°æ’: ${combatStats.collisions}`, 50, 300);
                }
                
                // æ˜¾ç¤ºæ§åˆ¶æç¤º
                this.ctx.fillStyle = '#AAA';
                this.ctx.font = '11px Arial';
                this.ctx.fillText('ç©å®¶1: WASDç§»åŠ¨ï¼Œç©ºæ ¼å°„å‡»', 50, 270);
                if (this.gameMode === 'DOUBLE') {
                    this.ctx.fillText('ç©å®¶2: æ–¹å‘é”®ç§»åŠ¨ï¼Œå›è½¦å°„å‡»', 50, 290);
                    this.ctx.fillText('æŒ‰Mé”®åˆ‡æ¢åœ°å›¾ï¼ŒæŒ‰Té”®æ·»åŠ æ•Œäººï¼ŒæŒ‰Ré”®é‡æ–°å¼€å§‹', 50, 310);
                } else {
                    this.ctx.fillText('æŒ‰Mé”®åˆ‡æ¢åœ°å›¾ï¼ŒæŒ‰Té”®æ·»åŠ æ•Œäººï¼ŒæŒ‰Ré”®é‡æ–°å¼€å§‹', 50, 290);
                }
            }

            drawTestTank(x, y) {
                // ç»˜åˆ¶ç®€å•çš„å¦å…‹å›¾å½¢
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fillRect(x - 16, y - 16, 32, 32);
                
                this.ctx.fillStyle = '#2E7D32';
                this.ctx.fillRect(x - 12, y - 12, 24, 24);
                
                // ç‚®ç®¡
                this.ctx.fillStyle = '#1B5E20';
                this.ctx.fillRect(x - 2, y - 20, 4, 16);
            }

            updateUI() {
                // æ›´æ–°å¾—åˆ†æ˜¾ç¤º
                const scoreStats = this.scoreComponent.getStats();
                const lifeStats = this.playerLifeSystem.getStats();
                const gameStats = this.gameStateManager.getStats();
                
                document.getElementById('score').textContent = scoreStats.currentScore.toLocaleString();
                
                // æ˜¾ç¤ºå…³å¡ä¿¡æ¯
                if (this.levelManager.currentLevel) {
                    document.getElementById('level').textContent = 
                        `${this.levelManager.currentLevelId}: ${this.levelManager.currentLevel.name}`;
                } else {
                    document.getElementById('level').textContent = gameStats.currentLevel;
                }
                
                document.getElementById('player1Lives').textContent = lifeStats.currentLives;
                document.getElementById('enemyCount').textContent = gameStats.levelData.enemiesTotal - gameStats.levelData.enemiesDestroyed;
                
                // æ›´æ–°æ¸¸æˆæ—¶é—´
                const minutes = Math.floor(this.gameData.gameTime / 60000);
                const seconds = Math.floor((this.gameData.gameTime % 60000) / 1000);
                document.getElementById('gameTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // æ˜¾ç¤ºè¿å‡»å’Œå€æ•°ä¿¡æ¯
                if (scoreStats.comboCount > 0) {
                    const comboElement = document.getElementById('combo');
                    if (comboElement) {
                        comboElement.textContent = `è¿å‡»: ${scoreStats.comboCount}`;
                        comboElement.style.display = 'block';
                    }
                } else {
                    const comboElement = document.getElementById('combo');
                    if (comboElement) {
                        comboElement.style.display = 'none';
                    }
                }
                
                if (scoreStats.multiplier > 1.0) {
                    const multiplierElement = document.getElementById('multiplier');
                    if (multiplierElement) {
                        multiplierElement.textContent = `å€æ•°: x${scoreStats.multiplier.toFixed(1)}`;
                        multiplierElement.style.display = 'block';
                    }
                } else {
                    const multiplierElement = document.getElementById('multiplier');
                    if (multiplierElement) {
                        multiplierElement.style.display = 'none';
                    }
                }
                
                // åŒäººæ¨¡å¼UI
                if (this.gameMode === 'DOUBLE') {
                    document.getElementById('player2Info').style.display = 'flex';
                    document.getElementById('player2Lives').textContent = this.gameData.player2Lives;
                } else {
                    document.getElementById('player2Info').style.display = 'none';
                }
            }

            showLoading(show) {
                const loadingEl = document.getElementById('loadingIndicator');
                if (show) {
                    loadingEl.classList.remove('hidden');
                } else {
                    loadingEl.classList.add('hidden');
                }
            }

            // æ¸¸æˆçŠ¶æ€æ§åˆ¶æ–¹æ³•
            startGame(mode = 'SINGLE') {
                console.log(`ğŸ® å¼€å§‹æ¸¸æˆ - æ¨¡å¼: ${mode}`);
                this.gameMode = mode;
                this.gameState = 'PLAYING';
                
                // éšè—èœå•
                document.getElementById('mainMenu').classList.add('hidden');
                
                // é‡ç½®æ¸¸æˆæ•°æ®
                this.resetGameData();
                
                // å¼€å§‹ç¬¬ä¸€å…³
                if (this.levelManager.startLevel(1)) {
                    // æ›´æ–°å…³å¡æ•°æ®åˆ°æ¸¸æˆçŠ¶æ€ç®¡ç†å™¨
                    const levelData = this.levelManager.getCurrentLevelStatus();
                    if (levelData) {
                        this.gameStateManager.updateLevelData({
                            enemiesTotal: levelData.enemies.total,
                            enemiesDestroyed: 0,
                            timeLimit: levelData.timeLimit,
                            timeRemaining: levelData.timeLimit,
                            objectivesTotal: levelData.objectives.length,
                            objectivesCompleted: 0
                        });
                    }
                    
                    // åŠ è½½åœ°å›¾
                    this.loadGameMap('test');
                    
                    // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                    if (this.audioManager) {
                        this.audioManager.playMusic('battle_theme', { fadeIn: true });
                    }
                    
                    console.log(`âœ… æ¸¸æˆå¼€å§‹ - å…³å¡1: ${this.levelManager.currentLevel.name}`);
                } else {
                    console.error('âŒ æ— æ³•å¼€å§‹ç¬¬ä¸€å…³');
                    // å›é€€åˆ°æ—§çš„å¼€å§‹æ–¹å¼
                    this.loadGameMap('test');
                    
                    // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                    if (this.audioManager) {
                        this.audioManager.playMusic('battle_theme', { fadeIn: true });
                    }
                    
                    console.log('âœ… æ¸¸æˆå¼€å§‹ï¼ˆå…¼å®¹æ¨¡å¼ï¼‰');
                }
            }

            // åŠ è½½æ¸¸æˆåœ°å›¾
            loadGameMap(mapName) {
                this.currentMap = this.mapManager.loadMap(mapName);
                if (this.currentMap) {
                    console.log('ğŸ—ºï¸ åœ°å›¾åŠ è½½æˆåŠŸ:', mapName);
                    
                    // æ¸…é™¤ç°æœ‰å®ä½“
                    this.entityManager.clear();
                    this.tankManager.clearAll();
                    
                    // åˆå§‹åŒ–é“å…·ç®¡ç†å™¨
                    this.powerUpManager = new PowerUpSystem.PowerUpManager(this.entityManager, this.currentMap);
                    console.log('âœ¨ é“å…·ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
                    
                    // åˆ›å»ºç©å®¶å¦å…‹
                    this.createPlayerTanks();
                    
                    // åˆ›å»ºä¸€äº›æµ‹è¯•æ•Œæ–¹å¦å…‹
                    this.createTestEnemyTanks();
                } else {
                    console.error('âŒ åœ°å›¾åŠ è½½å¤±è´¥:', mapName);
                }
            }

            // åˆ›å»ºç©å®¶å¦å…‹
            createPlayerTanks() {
                const playerSpawn = this.currentMap.getRandomPlayerSpawn();
                
                // åˆ›å»ºç©å®¶1å¦å…‹
                const player1Tank = this.tankManager.createPlayerTank(playerSpawn.x, playerSpawn.y, 1);
                console.log('ğŸš— åˆ›å»ºç©å®¶1å¦å…‹');
                
                // å¦‚æœæ˜¯åŒäººæ¨¡å¼ï¼Œåˆ›å»ºç©å®¶2å¦å…‹
                if (this.gameMode === 'DOUBLE') {
                    const player2Spawn = this.currentMap.getRandomPlayerSpawn();
                    const player2Tank = this.tankManager.createPlayerTank(player2Spawn.x, player2Spawn.y, 2);
                    console.log('ğŸš™ åˆ›å»ºç©å®¶2å¦å…‹');
                }
            }

            // åˆ›å»ºæµ‹è¯•æ•Œæ–¹å¦å…‹
            createTestEnemyTanks() {
                const enemySpawns = this.currentMap.enemySpawns;
                const enemyCount = Math.min(3, enemySpawns.length);
                
                for (let i = 0; i < enemyCount; i++) {
                    const spawn = enemySpawns[i % enemySpawns.length];
                    const tankType = i === 0 ? TankSystem.TankType.ENEMY_BASIC : 
                                   i === 1 ? TankSystem.TankType.ENEMY_FAST : 
                                   TankSystem.TankType.ENEMY_HEAVY;
                    
                    const enemyTank = this.tankManager.createEnemyTank(spawn.x, spawn.y, tankType);
                    
                    // ä¸ºæ•Œæ–¹å¦å…‹æ·»åŠ AI
                    this.addAIToTank(enemyTank, i);
                    
                    console.log('ğŸ¤– åˆ›å»ºæ•Œæ–¹å¦å…‹:', tankType);
                }
            }

            // ä¸ºå¦å…‹æ·»åŠ AI
            addAIToTank(tank, index = 0) {
                // æ ¹æ®ç´¢å¼•é€‰æ‹©ä¸åŒçš„AIè¡Œä¸º
                const behaviors = [
                    AISystem.AIBehavior.BALANCED,
                    AISystem.AIBehavior.AGGRESSIVE,
                    AISystem.AIBehavior.DEFENSIVE,
                    AISystem.AIBehavior.COWARD,
                    AISystem.AIBehavior.BERSERKER
                ];
                
                const difficulties = [
                    AdvancedAISystem.AIDifficulty.NORMAL,
                    AdvancedAISystem.AIDifficulty.HARD,
                    AdvancedAISystem.AIDifficulty.EASY,
                    AdvancedAISystem.AIDifficulty.EXPERT,
                    AdvancedAISystem.AIDifficulty.NIGHTMARE
                ];
                
                const behavior = behaviors[index % behaviors.length];
                const difficulty = difficulties[index % difficulties.length];
                
                // ä½¿ç”¨é«˜çº§AIæ§åˆ¶å™¨
                const aiController = new AdvancedAISystem.AdvancedAIController(behavior, difficulty);
                aiController.gameMap = this.gameMap;
                
                tank.addComponent(aiController);
                this.aiManager.addAI(tank);
                
                console.log('ğŸ§  æ·»åŠ é«˜çº§AIæ§åˆ¶å™¨:', behavior, difficulty);
            }

            pauseGame() {
                if (this.gameState === 'PLAYING') {
                    console.log('â¸ï¸ æ¸¸æˆæš‚åœ');
                    this.gameState = 'PAUSED';
                    document.getElementById('pauseOverlay').style.display = 'flex';
                    this.audioManager.pauseAll();
                }
            }

            resumeGame() {
                if (this.gameState === 'PAUSED') {
                    console.log('â–¶ï¸ æ¸¸æˆç»§ç»­');
                    this.gameState = 'PLAYING';
                    document.getElementById('pauseOverlay').style.display = 'none';
                    this.audioManager.resumeAll();
                }
            }

            restartGame() {
                console.log('ğŸ”„ é‡æ–°å¼€å§‹æ¸¸æˆ');
                this.resetGameData();
                this.gameState = 'PLAYING';
                document.getElementById('pauseOverlay').style.display = 'none';
            }

            backToMenu() {
                console.log('ğŸ  è¿”å›ä¸»èœå•');
                this.gameState = 'MENU';
                document.getElementById('mainMenu').classList.remove('hidden');
                document.getElementById('pauseOverlay').style.display = 'none';
                this.audioManager.stopAll();
            }

            resetGameData() {
                this.gameData = {
                    score: 0,
                    level: 1,
                    lives: 3,
                    enemyCount: 20,
                    gameTime: 0,
                    player1Lives: 3,
                    player2Lives: 3
                };
                this.updateUI();
            }

            // æ¸…é™¤æ‰€æœ‰æµ‹è¯•å®ä½“
            clearTestEntities() {
                // æ¸…é™¤æ‰€æœ‰å¦å…‹å’Œå­å¼¹
                this.tankManager.clearAll();
                const bullets = this.entityManager.getEntitiesByTag('bullet');
                bullets.forEach(bullet => this.entityManager.removeEntity(bullet));
                console.log('ğŸ§¹ æ¸…é™¤æ‰€æœ‰æµ‹è¯•å®ä½“');
            }

            // åˆ‡æ¢åœ°å›¾
            switchMap() {
                const mapList = this.mapManager.getMapList();
                const currentMapIndex = mapList.findIndex(name => 
                    this.currentMap && this.mapManager.mapLibrary.get(name) === this.currentMap.exportData()
                );
                const nextMapIndex = (currentMapIndex + 1) % mapList.length;
                const nextMapName = mapList[nextMapIndex];
                
                console.log('ğŸ—ºï¸ åˆ‡æ¢åœ°å›¾:', nextMapName);
                this.loadGameMap(nextMapName);
            }

            // åˆ›å»ºå­å¼¹
            createBullet(bulletData) {
                // ä½¿ç”¨å°„å‡»ç³»ç»Ÿåˆ›å»ºå­å¼¹
                const bullet = this.fireSystem.createBullet(bulletData);
                
                // æ·»åŠ åˆ°å®ä½“ç®¡ç†å™¨
                this.entityManager.addEntity(bullet);
                
                // è®¾ç½®å­å¼¹è¡Œä¸º
                this.setupBulletBehavior(bullet);
                
                return bullet;
            }

            // è®¾ç½®å­å¼¹è¡Œä¸º
            setupBulletBehavior(bullet) {
                const originalUpdate = bullet.update.bind(bullet);
                bullet.update = (deltaTime) => {
                    originalUpdate(deltaTime);
                    
                    const transform = bullet.getComponent('Transform');
                    const bulletComponent = bullet.getComponent('Bullet');
                    
                    if (!transform || !bulletComponent || !bulletComponent.active) return;
                    
                    // æ£€æŸ¥åœ°å›¾ç¢°æ’
                    if (this.currentMap) {
                        const tilePos = this.currentMap.worldToTile(transform.x, transform.y);
                        const tile = this.currentMap.getTile(tilePos.x, tilePos.y);
                        
                        if (tile && tile.isSolid()) {
                            // å­å¼¹å‡»ä¸­ç“¦ç‰‡
                            bulletComponent.hitTile(tile, transform.x, transform.y);
                            return;
                        }
                    }
                    
                    // å¦å…‹ç¢°æ’ç°åœ¨ç”±æˆ˜æ–—ç³»ç»Ÿå¤„ç†
                };
            }



            // ç©å®¶å¦å…‹è¢«æ‘§æ¯äº‹ä»¶
            onPlayerTankDestroyed(tank) {
                console.log('ğŸ”¥ ç©å®¶å¦å…‹è¢«æ‘§æ¯');
                
                // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
                const transform = tank.getComponent('Transform');
                if (this.audioManager && transform) {
                    this.audioManager.playSFX('tank_explosion', {
                        position: { x: transform.x, y: transform.y }
                    });
                }
                
                // ä½¿ç”¨ç”Ÿå‘½å€¼ç³»ç»Ÿ
                if (this.playerLifeSystem.loseLife()) {
                    // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
                    if (this.playerLifeSystem.isDead()) {
                        this.endGame(false);
                    } else {
                        // é‡ç”Ÿå¦å…‹ï¼ˆç”Ÿå‘½å€¼ç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†é‡ç”Ÿè®¡æ—¶ï¼‰
                        this.schedulePlayerRespawn(tank);
                    }
                }
            }
            
            // å®‰æ’ç©å®¶é‡ç”Ÿ
            schedulePlayerRespawn(destroyedTank) {
                const checkRespawn = () => {
                    if (!this.playerLifeSystem.isRespawning) {
                        this.respawnPlayerTank(destroyedTank);
                    } else {
                        setTimeout(checkRespawn, 100);
                    }
                };
                checkRespawn();
            }

            // æ•Œæ–¹å¦å…‹è¢«æ‘§æ¯äº‹ä»¶
            onEnemyTankDestroyed(tank) {
                console.log('ğŸ’¥ æ•Œæ–¹å¦å…‹è¢«æ‘§æ¯');
                
                // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
                const transform = tank.getComponent('Transform');
                if (this.audioManager && transform) {
                    this.audioManager.playSFX('tank_explosion', {
                        position: { x: transform.x, y: transform.y }
                    });
                }
                
                // ä»AIç®¡ç†å™¨ä¸­ç§»é™¤
                this.aiManager.removeAI(tank);
                
                // æ ¹æ®å¦å…‹ç±»å‹ç»™äºˆä¸åŒåˆ†æ•°
                const tankType = tank.getComponent('TankType');
                let points = 100;
                let enemyType = 'ENEMY_BASIC';
                
                if (tankType) {
                    switch (tankType.type) {
                        case TankSystem.TankType.ENEMY_FAST:
                            points = 200;
                            enemyType = 'ENEMY_FAST';
                            break;
                        case TankSystem.TankType.ENEMY_HEAVY:
                            points = 300;
                            enemyType = 'ENEMY_HEAVY';
                            break;
                        default:
                            points = 100;
                            enemyType = 'ENEMY_BASIC';
                    }
                }
                
                // ä½¿ç”¨æ–°çš„å¾—åˆ†ç³»ç»Ÿ
                this.scoreComponent.addScore(points, ScoreSystem.ScoreEventType.ENEMY_DESTROYED, {
                    enemyType: enemyType
                });
                
                // æ›´æ–°å…³å¡æ•°æ®
                const levelData = this.gameStateManager.levelData;
                levelData.enemiesDestroyed++;
                this.gameStateManager.updateLevelData(levelData);
                
                // æ›´æ–°å…³å¡ç³»ç»Ÿçš„ç›®æ ‡è¿›åº¦
                if (this.levelManager.currentLevel) {
                    // æ›´æ–°"æ¶ˆç­æ‰€æœ‰æ•Œäºº"ç›®æ ‡
                    for (let i = 0; i < this.levelManager.currentLevel.objectives.length; i++) {
                        const objective = this.levelManager.currentLevel.objectives[i];
                        if (objective.type === LevelSystem.ObjectiveType.DESTROY_ALL_ENEMIES) {
                            this.levelManager.updateObjective(i, levelData.enemiesDestroyed);
                        }
                    }
                }
                
                // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
                const aliveEnemies = this.tankManager.getAliveEnemies();
                const levelComplete = this.levelManager.currentLevel ? 
                    this.levelManager.checkLevelComplete() : 
                    this.gameStateManager.checkLevelComplete();
                
                if (aliveEnemies.length === 0 || levelComplete) {
                    this.levelComplete();
                }
            }

            // é‡ç”Ÿç©å®¶å¦å…‹
            respawnPlayerTank(destroyedTank) {
                const controller = destroyedTank.getComponent('TankController');
                if (!controller) return;
                
                const playerId = controller.playerId;
                const playerSpawn = this.currentMap.getRandomPlayerSpawn();
                
                // ç§»é™¤æ—§å¦å…‹
                this.tankManager.removeTank(destroyedTank);
                
                // åˆ›å»ºæ–°å¦å…‹
                const newTank = this.tankManager.createPlayerTank(playerSpawn.x, playerSpawn.y, playerId);
                
                // çŸ­æš‚æ— æ•Œæ—¶é—´
                const health = newTank.getComponent('Health');
                if (health) {
                    health.setInvulnerable(3000); // 3ç§’æ— æ•Œ
                }
                
                console.log(`ğŸ”„ ç©å®¶${playerId}å¦å…‹é‡ç”Ÿ`);
            }

            // å…³å¡å®Œæˆ
            levelComplete() {
                console.log('ğŸ‰ å…³å¡å®Œæˆï¼');
                
                // æ’­æ”¾å…³å¡å®ŒæˆéŸ³æ•ˆ
                if (this.audioManager) {
                    this.audioManager.playSFX('level_complete');
                }
                
                if (this.levelManager.currentLevel) {
                    // è®¡ç®—å…³å¡å®Œæˆæ—¶é—´
                    const completionTime = this.gameData.gameTime;
                    const currentScore = this.scoreComponent.getStats().currentScore;
                    const objectives = this.levelManager.currentLevel.objectives;
                    
                    // å®Œæˆå½“å‰å…³å¡
                    this.levelManager.completeLevel(currentScore, completionTime, objectives);
                    
                    // ç»™äºˆå…³å¡å®Œæˆå¥–åŠ±
                    this.scoreComponent.completeLevel(
                        Math.max(0, this.levelManager.currentLevel.timeLimit - completionTime) / 1000,
                        objectives.filter(obj => obj.completed).length
                    );
                    
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šå…³å¡
                    const nextLevelId = this.levelManager.currentLevelId + 1;
                    const nextLevel = this.levelManager.levels.get(nextLevelId);
                    
                    if (nextLevel && nextLevel.isUnlocked) {
                        // åŠ è½½ä¸‹ä¸€å…³
                        setTimeout(() => {
                            this.startNextLevel(nextLevelId);
                        }, 3000);
                    } else {
                        // æ¸¸æˆèƒœåˆ©
                        this.endGame(true);
                    }
                } else {
                    // æ—§çš„å…³å¡å®Œæˆé€»è¾‘ï¼ˆå‘åå…¼å®¹ï¼‰
                    this.gameData.level++;
                    this.scoreComponent.addScore(1000, ScoreSystem.ScoreEventType.LEVEL_COMPLETED);
                    
                    if (this.gameData.level > 10) {
                        this.endGame(true);
                    } else {
                        setTimeout(() => {
                            this.loadGameMap('test');
                        }, 2000);
                    }
                }
            }
            
            // å¼€å§‹ä¸‹ä¸€å…³
            startNextLevel(levelId) {
                if (this.levelManager.startLevel(levelId)) {
                    // é‡ç½®æ¸¸æˆçŠ¶æ€
                    this.gameData.gameTime = 0;
                    
                    // æ›´æ–°å…³å¡æ•°æ®åˆ°æ¸¸æˆçŠ¶æ€ç®¡ç†å™¨
                    const levelData = this.levelManager.getCurrentLevelStatus();
                    if (levelData) {
                        this.gameStateManager.updateLevelData({
                            enemiesTotal: levelData.enemies.total,
                            enemiesDestroyed: 0,
                            timeLimit: levelData.timeLimit,
                            timeRemaining: levelData.timeLimit,
                            objectivesTotal: levelData.objectives.length,
                            objectivesCompleted: 0
                        });
                    }
                    
                    // é‡æ–°åŠ è½½åœ°å›¾
                    this.loadGameMap('test');
                    
                    console.log(`ğŸš€ å¼€å§‹å…³å¡ ${levelId}: ${this.levelManager.currentLevel.name}`);
                } else {
                    console.error(`âŒ æ— æ³•å¼€å§‹å…³å¡ ${levelId}`);
                    this.endGame(false);
                }
            }

            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            createExplosion(x, y, radius = 50) {
                const explosion = new ECS.Entity('Explosion');
                
                // æ·»åŠ å˜æ¢ç»„ä»¶
                explosion.addComponent(new ECS.Transform(x, y, 0));
                
                // æ·»åŠ çˆ†ç‚¸ç»„ä»¶
                explosion.addComponent(new BulletSystem.Explosion(radius, 1000));
                explosion.addComponent(new BulletSystem.ExplosionRenderer());
                
                // æ·»åŠ æ ‡ç­¾
                explosion.addTag('explosion');
                explosion.addTag('effect');
                
                // æ·»åŠ åˆ°å®ä½“ç®¡ç†å™¨
                this.entityManager.addEntity(explosion);
                
                // æ’­æ”¾çˆ†ç‚¸éŸ³æ•ˆ
                if (this.audioManager) {
                    this.audioManager.playSound('explosion');
                }
                
                return explosion;
            }

            // è®¾ç½®æˆ˜æ–—äº‹ä»¶ç›‘å¬å™¨
            setupCombatEventListeners() {
                // ç›‘å¬ä¼¤å®³äº‹ä»¶ï¼Œæ˜¾ç¤ºä¼¤å®³æ•°å­—
                this.combatManager.addEventListener(CombatSystem.CombatEvent.DAMAGE_DEALT, (data) => {
                    const transform = data.target.getComponent('Transform');
                    if (transform) {
                        this.damageNumberSystem.showDamage(
                            transform.x, 
                            transform.y - 20, 
                            data.damage, 
                            data.damageType
                        );
                    }
                });
                
                // ç›‘å¬å¦å…‹æ‘§æ¯äº‹ä»¶
                this.combatManager.addEventListener(CombatSystem.CombatEvent.TANK_DESTROYED, (data) => {
                    console.log('ğŸ’¥ æˆ˜æ–—ç³»ç»Ÿï¼šå¦å…‹è¢«æ‘§æ¯');
                });
                
                // ç›‘å¬å­å¼¹å‡»ä¸­äº‹ä»¶
                this.combatManager.addEventListener(CombatSystem.CombatEvent.BULLET_HIT, (data) => {
                    console.log('ğŸ¯ æˆ˜æ–—ç³»ç»Ÿï¼šå­å¼¹å‡»ä¸­ç›®æ ‡ï¼Œä¼¤å®³:', data.damage);
                });
                
                // ç›‘å¬ç¢°æ’äº‹ä»¶
                this.combatManager.addEventListener(CombatSystem.CombatEvent.COLLISION_OCCURRED, (data) => {
                    console.log('ğŸ’¥ æˆ˜æ–—ç³»ç»Ÿï¼šå‘ç”Ÿç¢°æ’');
                });
            }

            // æ¸¸æˆç»“æŸ
            endGame(victory) {
                this.gameState = 'GAME_OVER';
                
                // æ’­æ”¾æ¸¸æˆç»“æŸéŸ³æ•ˆ
                if (this.audioManager) {
                    if (victory) {
                        this.audioManager.playMusic('victory_theme');
                    } else {
                        this.audioManager.playSFX('game_over');
                    }
                }
                
                const title = victory ? 'ğŸ† æ­å–œèƒœåˆ©ï¼' : 'ğŸ’€ æ¸¸æˆç»“æŸ';
                const combatStats = this.combatManager.getStats();
                const scoreStats = this.scoreComponent.getStats();
                const message = victory ? 
                    `å¤ªæ£’äº†ï¼ä½ å®Œæˆäº†æ‰€æœ‰å…³å¡ï¼<br>æœ€ç»ˆå¾—åˆ†ï¼š${scoreStats.currentScore}<br>æ€»ä¼¤å®³ï¼š${combatStats.totalDamageDealt}<br>æ‘§æ¯å¦å…‹ï¼š${combatStats.tanksDestroyed}` :
                    `æ¸¸æˆç»“æŸï¼<br>æœ€ç»ˆå¾—åˆ†ï¼š${scoreStats.currentScore}<br>åˆ°è¾¾å…³å¡ï¼š${this.gameData.level}<br>æ€»ä¼¤å®³ï¼š${combatStats.totalDamageDealt}`;
                
                // æ˜¾ç¤ºç»“æœï¼ˆè¿™é‡Œå¯ä»¥æ·»åŠ æ¸¸æˆç»“æŸç•Œé¢ï¼‰
                setTimeout(() => {
                    alert(title + '\n' + message.replace(/<br>/g, '\n'));
                    this.backToMenu();
                }, 1000);
            }
        }

        // è¾“å…¥ç®¡ç†å™¨
        class InputManager {
            constructor() {
                this.keys = {};
                this.keyPressed = {};
                this.keyReleased = {};
            }

            init() {
                console.log('âŒ¨ï¸ åˆå§‹åŒ–è¾“å…¥ç®¡ç†å™¨');
                
                // é”®ç›˜äº‹ä»¶ç›‘å¬
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // é˜²æ­¢é»˜è®¤è¡Œä¸º
                document.addEventListener('keydown', (e) => {
                    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                        e.preventDefault();
                    }
                });
            }

            onKeyDown(event) {
                const key = event.code;
                if (!this.keys[key]) {
                    this.keyPressed[key] = true;
                }
                this.keys[key] = true;
            }

            onKeyUp(event) {
                const key = event.code;
                this.keys[key] = false;
                this.keyReleased[key] = true;
            }

            update() {
                // æ¸…é™¤å•æ¬¡æŒ‰é”®çŠ¶æ€
                this.keyPressed = {};
                this.keyReleased = {};
            }

            isKeyDown(key) {
                return !!this.keys[key];
            }

            isKeyPressed(key) {
                return !!this.keyPressed[key];
            }

            isKeyReleased(key) {
                return !!this.keyReleased[key];
            }
        }

        // éŸ³é¢‘ç®¡ç†å™¨
        class AudioManager {
            constructor() {
                this.sounds = new Map();
                this.musicVolume = 0.7;
                this.sfxVolume = 0.8;
                this.muted = false;
                this.currentMusic = null;
            }

            init() {
                console.log('ğŸ”Š åˆå§‹åŒ–éŸ³é¢‘ç®¡ç†å™¨');
                
                // è¿™é‡Œåç»­ä¼šåŠ è½½éŸ³é¢‘æ–‡ä»¶
                this.createTestSounds();
            }

            createTestSounds() {
                // åˆ›å»ºæµ‹è¯•éŸ³æ•ˆï¼ˆä½¿ç”¨Web Audio APIï¼‰
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioContext = audioContext;
                    console.log('âœ… Web Audio API åˆå§‹åŒ–æˆåŠŸ');
                } catch (error) {
                    console.warn('âš ï¸ Web Audio API ä¸æ”¯æŒï¼Œä½¿ç”¨é™éŸ³æ¨¡å¼');
                    this.muted = true;
                }
            }

            playSound(name, volume = 1) {
                if (this.muted) return;
                
                // è¿™é‡Œåç»­ä¼šå®ç°éŸ³æ•ˆæ’­æ”¾
                console.log(`ğŸ”Š æ’­æ”¾éŸ³æ•ˆ: ${name}`);
            }

            playMusic(name, loop = true) {
                if (this.muted) return;
                
                // è¿™é‡Œåç»­ä¼šå®ç°èƒŒæ™¯éŸ³ä¹æ’­æ”¾
                console.log(`ğŸµ æ’­æ”¾éŸ³ä¹: ${name}`);
            }

            pauseAll() {
                // æš‚åœæ‰€æœ‰éŸ³é¢‘
                console.log('â¸ï¸ æš‚åœæ‰€æœ‰éŸ³é¢‘');
            }

            resumeAll() {
                // æ¢å¤æ‰€æœ‰éŸ³é¢‘
                console.log('â–¶ï¸ æ¢å¤æ‰€æœ‰éŸ³é¢‘');
            }

            stopAll() {
                // åœæ­¢æ‰€æœ‰éŸ³é¢‘
                console.log('â¹ï¸ åœæ­¢æ‰€æœ‰éŸ³é¢‘');
            }

            setVolume(type, volume) {
                if (type === 'music') {
                    this.musicVolume = volume;
                } else if (type === 'sfx') {
                    this.sfxVolume = volume;
                }
                console.log(`ğŸ”Š è®¾ç½®${type}éŸ³é‡: ${volume}`);
            }

            toggleMute() {
                this.muted = !this.muted;
                console.log(`ğŸ”‡ éŸ³é¢‘${this.muted ? 'é™éŸ³' : 'å¼€å¯'}`);
                return this.muted;
            }
        }

        // èµ„æºç®¡ç†å™¨
        class AssetManager {
            constructor() {
                this.images = new Map();
                this.sounds = new Map();
                this.loaded = false;
            }

            async loadAssets() {
                console.log('ğŸ“¦ å¼€å§‹åŠ è½½æ¸¸æˆèµ„æº...');
                
                try {
                    // è¿™é‡Œåç»­ä¼šåŠ è½½å®é™…çš„å›¾ç‰‡å’ŒéŸ³é¢‘èµ„æº
                    await this.loadTestAssets();
                    
                    this.loaded = true;
                    console.log('âœ… æ¸¸æˆèµ„æºåŠ è½½å®Œæˆ');
                } catch (error) {
                    console.error('âŒ èµ„æºåŠ è½½å¤±è´¥:', error);
                    throw error;
                }
            }

            async loadTestAssets() {
                // åˆ›å»ºæµ‹è¯•ç”¨çš„Canvaså›¾åƒ
                await this.createTestSprites();
            }

            async createTestSprites() {
                // åˆ›å»ºæµ‹è¯•ç²¾çµå›¾
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 32;
                canvas.height = 32;
                
                // åˆ›å»ºç©å®¶å¦å…‹ç²¾çµ
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(0, 0, 32, 32);
                ctx.fillStyle = '#2E7D32';
                ctx.fillRect(4, 4, 24, 24);
                
                this.images.set('player_tank', canvas);
                
                console.log('ğŸ¨ æµ‹è¯•ç²¾çµåˆ›å»ºå®Œæˆ');
            }

            getImage(name) {
                return this.images.get(name);
            }

            getSound(name) {
                return this.sounds.get(name);
            }
        }

        // å…¨å±€æ¸¸æˆå®ä¾‹
        let game;

        // å…¨å±€å‡½æ•°
        function startSinglePlayer() {
            if (game.audioManager) {
                game.audioManager.playSFX('menu_select');
            }
            game.startGame('SINGLE');
        }

        function startTwoPlayer() {
            if (game.audioManager) {
                game.audioManager.playSFX('menu_select');
            }
            game.startGame('DOUBLE');
        }

        function showSettings() {
            alert('è®¾ç½®åŠŸèƒ½å°†åœ¨åç»­ç‰ˆæœ¬ä¸­å®ç°');
        }

        function showHelp() {
            alert('æ¸¸æˆå¸®åŠ©ï¼š\n\nç©å®¶1æ§åˆ¶ï¼šWASDç§»åŠ¨ï¼Œç©ºæ ¼å°„å‡»\nç©å®¶2æ§åˆ¶ï¼šæ–¹å‘é”®ç§»åŠ¨ï¼Œå›è½¦å°„å‡»\n\nPé”®æš‚åœï¼ŒRé”®é‡æ–°å¼€å§‹ï¼ŒESCé”®è¿”å›èœå•');
        }

        function resumeGame() {
            game.resumeGame();
        }

        function restartGame() {
            game.restartGame();
        }

        function backToMenu() {
            game.backToMenu();
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ¸¸æˆ
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–å¦å…‹å¤§æˆ˜æ¸¸æˆ');
            game = new GameEngine();
        });

        // å…¨å±€é”®ç›˜äº‹ä»¶å¤„ç†
        document.addEventListener('keydown', (e) => {
            if (!game) return;
            
            switch (e.code) {
                case 'KeyP':
                    if (game.gameState === 'PLAYING') {
                        game.pauseGame();
                    } else if (game.gameState === 'PAUSED') {
                        game.resumeGame();
                    }
                    break;
                case 'KeyR':
                    if (game.gameState === 'PLAYING' || game.gameState === 'PAUSED') {
                        game.restartGame();
                    }
                    break;
                case 'Escape':
                    if (game.gameState === 'PLAYING' || game.gameState === 'PAUSED') {
                        game.backToMenu();
                    }
                    break;
                case 'KeyT':
                    // åˆ›å»ºæµ‹è¯•æ•Œæ–¹å¦å…‹
                    if (game.gameState === 'PLAYING' && game.currentMap) {
                        const spawn = game.currentMap.getRandomEnemySpawn();
                        const enemyTank = game.tankManager.createEnemyTank(spawn.x, spawn.y, TankSystem.TankType.ENEMY_BASIC);
                        
                        // æ·»åŠ AI
                        const aiStats = game.aiManager.getStats();
                        game.addAIToTank(enemyTank, aiStats.totalAI);
                        
                        console.log('ğŸ¤– åˆ›å»ºå¸¦AIçš„æ•Œæ–¹å¦å…‹');
                    }
                    break;
                case 'KeyC':
                    // æ¸…é™¤æµ‹è¯•å®ä½“
                    if (game.gameState === 'PLAYING') {
                        game.clearTestEntities();
                    }
                    break;
                case 'KeyP':
                    // ç”Ÿæˆéšæœºé“å…·
                    if (game.gameState === 'PLAYING' && game.powerUpManager) {
                        game.powerUpManager.spawnRandomPowerUp();
                        console.log('âœ¨ ç”Ÿæˆéšæœºé“å…·');
                    }
                    break;
                case 'KeyO':
                    // æµ‹è¯•å¾—åˆ†ç³»ç»Ÿ
                    if (game.gameState === 'PLAYING') {
                        game.scoreComponent.addScore(500, ScoreSystem.ScoreEventType.BONUS_ACHIEVED);
                        console.log('ğŸ’° æµ‹è¯•å¥–åŠ±å¾—åˆ†');
                    }
                    break;
                case 'KeyL':
                    // æµ‹è¯•ç”Ÿå‘½å€¼ç³»ç»Ÿ
                    if (game.gameState === 'PLAYING') {
                        game.playerLifeSystem.gainLife();
                        console.log('â¤ï¸ è·å¾—é¢å¤–ç”Ÿå‘½');
                    }
                    break;
                case 'KeyN':
                    // å¼€å§‹ä¸‹ä¸€å…³
                    if (game.gameState === 'PLAYING' && game.levelManager.currentLevel) {
                        const nextLevelId = game.levelManager.currentLevelId + 1;
                        if (game.levelManager.levels.has(nextLevelId)) {
                            game.startNextLevel(nextLevelId);
                            console.log('ğŸš€ è·³è½¬åˆ°ä¸‹ä¸€å…³');
                        }
                    }
                    break;
                case 'KeyB':
                    // å¼€å§‹æŒ‡å®šå…³å¡
                    if (game.gameState === 'PLAYING') {
                        const levelId = prompt('è¾“å…¥å…³å¡ID (1-16):');
                        if (levelId && !isNaN(levelId)) {
                            const id = parseInt(levelId);
                            if (game.levelManager.levels.has(id)) {
                                // ä¸´æ—¶è§£é”å…³å¡ç”¨äºæµ‹è¯•
                                game.levelManager.levels.get(id).isUnlocked = true;
                                game.startNextLevel(id);
                                console.log(`ğŸ¯ å¼€å§‹å…³å¡ ${id}`);
                            }
                        }
                    }
                    break;
                case 'KeyV':
                    // è°ƒæ•´éŸ³é‡
                    if (game.audioManager) {
                        const currentVolume = game.audioManager.masterVolume;
                        const newVolume = currentVolume > 0.5 ? 0.2 : 1.0;
                        game.audioManager.setMasterVolume(newVolume);
                        console.log(`ğŸ”Š éŸ³é‡è°ƒæ•´: ${Math.round(newVolume * 100)}%`);
                    }
                    break;
                case 'KeyU':
                    // åˆ‡æ¢éŸ³ä¹
                    if (game.audioManager) {
                        const musicList = ['main_theme', 'battle_theme', 'boss_theme'];
                        const currentMusic = game.audioManager.currentMusic?.id;
                        const currentIndex = musicList.indexOf(currentMusic);
                        const nextIndex = (currentIndex + 1) % musicList.length;
                        const nextMusic = musicList[nextIndex];
                        
                        game.audioManager.playMusic(nextMusic, { crossFade: true });
                        console.log(`ğŸµ åˆ‡æ¢éŸ³ä¹: ${nextMusic}`);
                    }
                    break;
                case 'KeyM':
                    // åˆ‡æ¢åœ°å›¾
                    if (game.gameState === 'PLAYING') {
                        game.switchMap();
                    }
                    break;
            }
        });

        // é˜²æ­¢é¡µé¢æ»šåŠ¨å’Œç¼©æ”¾
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        // å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
        document.addEventListener('visibilitychange', function() {
            if (game && game.gameState === 'PLAYING' && document.hidden) {
                game.pauseGame();
            }
        });

        // å¤„ç†çª—å£å¤±ç„¦
        window.addEventListener('blur', function() {
            if (game && game.gameState === 'PLAYING') {
                game.pauseGame();
            }
        });
    </script>
</body>
</html>