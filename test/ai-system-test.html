<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç³»ç»Ÿæµ‹è¯• - AI System Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        #aiCanvas {
            border: 2px solid #333;
            background: #000;
        }
        .controls {
            margin: 10px 0;
        }
        .ai-info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .ai-behaviors {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .behavior-sample {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .behavior-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
        .ai-status {
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>ğŸ§  AIç³»ç»Ÿæµ‹è¯•</h1>
    
    <div class="test-container">
        <h2>ğŸ“‹ æµ‹è¯•ç»“æœ</h2>
        <div id="testResults"></div>
        <button onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
        <button onclick="clearResults()">ğŸ§¹ æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="test-container">
        <h2>ğŸ® AIå¯è§†åŒ–æµ‹è¯•</h2>
        <canvas id="aiCanvas" width="800" height="600"></canvas>
        <div class="controls">
            <button onclick="createAITank('aggressive')">ğŸ˜¡ æ¿€è¿›å‹AI</button>
            <button onclick="createAITank('defensive')">ğŸ›¡ï¸ é˜²å®ˆå‹AI</button>
            <button onclick="createAITank('balanced')">âš–ï¸ å¹³è¡¡å‹AI</button>
            <button onclick="createAITank('coward')">ğŸ˜¨ èƒ†å°å‹AI</button>
            <button onclick="createAITank('berserker')">ğŸ˜¤ ç‹‚æš´å‹AI</button>
        </div>
        <div class="controls">
            <button onclick="createPlayerTank()">ğŸš— åˆ›å»ºç©å®¶å¦å…‹</button>
            <button onclick="testPathfinding()">ğŸ—ºï¸ æµ‹è¯•å¯»è·¯</button>
            <button onclick="showAIStates()">ğŸ“Š æ˜¾ç¤ºAIçŠ¶æ€</button>
            <button onclick="clearAll()">ğŸ§¹ æ¸…é™¤æ‰€æœ‰</button>
        </div>
        <div class="controls">
            <p><strong>è¯´æ˜ï¼š</strong> åˆ›å»ºAIå¦å…‹åï¼Œå®ƒä»¬ä¼šè‡ªåŠ¨å¯»æ‰¾å’Œæ”»å‡»ç©å®¶å¦å…‹</p>
        </div>
    </div>

    <div class="test-container">
        <h2>ğŸ“Š AIä¿¡æ¯</h2>
        <div class="ai-info" id="aiInfo">
            <p>AIå®ä½“æ•°é‡: <span id="aiCount">0</span></p>
            <p>ç©å®¶å¦å…‹æ•°é‡: <span id="playerCount">0</span></p>
        </div>
        
        <h3>AIè¡Œä¸ºç±»å‹</h3>
        <div class="ai-behaviors">
            <div class="behavior-sample">
                <div class="behavior-color" style="background: #FF5722;"></div>
                <span>æ¿€è¿›å‹ - ä¸»åŠ¨æ”»å‡»</span>
            </div>
            <div class="behavior-sample">
                <div class="behavior-color" style="background: #2196F3;"></div>
                <span>é˜²å®ˆå‹ - ä¿å®ˆæˆ˜æ–—</span>
            </div>
            <div class="behavior-sample">
                <div class="behavior-color" style="background: #4CAF50;"></div>
                <span>å¹³è¡¡å‹ - å‡è¡¡ç­–ç•¥</span>
            </div>
            <div class="behavior-sample">
                <div class="behavior-color" style="background: #FFC107;"></div>
                <span>èƒ†å°å‹ - å®¹æ˜“æ’¤é€€</span>
            </div>
            <div class="behavior-sample">
                <div class="behavior-color" style="background: #9C27B0;"></div>
                <span>ç‹‚æš´å‹ - ç–¯ç‹‚æ”»å‡»</span>
            </div>
        </div>
        
        <h3>AIçŠ¶æ€ç›‘æ§</h3>
        <div class="ai-status" id="aiStatus">
            ç­‰å¾…AIåˆ›å»º...
        </div>
    </div>

    <!-- å¼•å…¥ä¾èµ– -->
    <script src="../js/entity-component-system.js"></script>
    <script src="../js/map-system.js"></script>
    <script src="../js/tank-system.js"></script>
    <script src="../js/bullet-system.js"></script>
    <script src="../js/ai-system.js"></script>
    
    <script>
        // æµ‹è¯•ç®¡ç†å™¨
        class AITestManager {
            constructor() {
                this.results = [];
                this.entityManager = new ECS.EntityManager();
                this.tankManager = new TankSystem.TankManager(this.entityManager);
                this.aiManager = new AISystem.AIManager(this.entityManager);
                this.fireSystem = new BulletSystem.FireSystem();
                this.canvas = document.getElementById('aiCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                // åˆ›å»ºç®€å•åœ°å›¾
                this.gameMap = new MapSystem.GameMap(25, 19, 32);
                this.setupTestMap();
                
                // è®¾ç½®å…¨å±€å¼•ç”¨
                window.game = {
                    entityManager: this.entityManager,
                    canvas: this.canvas,
                    currentMap: this.gameMap,
                    inputManager: { isKeyDown: () => false, isKeyPressed: () => false },
                    createBullet: (bulletData) => this.createBullet(bulletData),
                    createExplosion: (x, y, radius) => this.createExplosion(x, y, radius),
                    onPlayerTankDestroyed: () => console.log('ç©å®¶å¦å…‹è¢«æ‘§æ¯'),
                    onEnemyTankDestroyed: () => console.log('æ•Œæ–¹å¦å…‹è¢«æ‘§æ¯')
                };
                
                this.pathVisualization = [];
                this.showPaths = false;
                
                this.startRenderLoop();
            }

            setupTestMap() {
                // åˆ›å»ºè¾¹æ¡†
                this.gameMap.drawBorder(MapSystem.TileType.STEEL);
                
                // æ·»åŠ ä¸€äº›éšœç¢ç‰©
                for (let i = 0; i < 15; i++) {
                    const x = Math.floor(Math.random() * (this.gameMap.width - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.gameMap.height - 4)) + 2;
                    this.gameMap.setTile(x, y, MapSystem.TileType.BRICK);
                }
                
                // æ·»åŠ ç”Ÿæˆç‚¹
                this.gameMap.setTile(2, this.gameMap.height - 3, MapSystem.TileType.SPAWN_PLAYER);
                this.gameMap.setTile(this.gameMap.width - 3, 2, MapSystem.TileType.SPAWN_ENEMY);
            }

            createBullet(bulletData) {
                const bullet = this.fireSystem.createBullet(bulletData);
                this.entityManager.addEntity(bullet);
                
                // ç®€å•çš„è¾¹ç•Œæ£€æŸ¥
                const originalUpdate = bullet.update.bind(bullet);
                bullet.update = (deltaTime) => {
                    originalUpdate(deltaTime);
                    
                    const transform = bullet.getComponent('Transform');
                    if (transform) {
                        if (transform.x < 0 || transform.x > this.canvas.width ||
                            transform.y < 0 || transform.y > this.canvas.height) {
                            this.entityManager.removeEntity(bullet);
                        }
                    }
                };
                
                return bullet;
            }

            createExplosion(x, y, radius = 50) {
                const explosion = new ECS.Entity('Explosion');
                explosion.addComponent(new ECS.Transform(x, y, 0));
                explosion.addComponent(new BulletSystem.Explosion(radius, 1000));
                explosion.addComponent(new BulletSystem.ExplosionRenderer());
                explosion.addTag('explosion');
                this.entityManager.addEntity(explosion);
                return explosion;
            }

            // æ·»åŠ æµ‹è¯•ç»“æœ
            addResult(testName, passed, message = '') {
                this.results.push({
                    name: testName,
                    passed: passed,
                    message: message,
                    timestamp: new Date().toLocaleTimeString()
                });
                this.updateResultsDisplay();
            }

            // æ›´æ–°ç»“æœæ˜¾ç¤º
            updateResultsDisplay() {
                const container = document.getElementById('testResults');
                container.innerHTML = '';
                
                this.results.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                    div.innerHTML = `
                        <strong>${result.passed ? 'âœ…' : 'âŒ'} ${result.name}</strong>
                        <br><small>${result.timestamp}</small>
                        ${result.message ? `<br>${result.message}` : ''}
                    `;
                    container.appendChild(div);
                });
            }

            // æ¸…é™¤ç»“æœ
            clearResults() {
                this.results = [];
                this.updateResultsDisplay();
            }

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            startRenderLoop() {
                const render = () => {
                    this.update();
                    this.render();
                    this.updateInfo();
                    requestAnimationFrame(render);
                };
                render();
            }

            // æ›´æ–°
            update() {
                this.entityManager.update(16);
                this.fireSystem.update(16);
                this.aiManager.update(16);
            }

            // æ¸²æŸ“
            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // æ¸²æŸ“åœ°å›¾
                this.gameMap.render(this.ctx);
                
                // æ¸²æŸ“è·¯å¾„å¯è§†åŒ–
                if (this.showPaths) {
                    this.renderPathVisualization();
                }
                
                // æ¸²æŸ“æ‰€æœ‰å®ä½“
                this.entityManager.render(this.ctx);
                
                // æ¸²æŸ“AIçŠ¶æ€ä¿¡æ¯
                this.renderAIInfo();
            }

            // æ¸²æŸ“è·¯å¾„å¯è§†åŒ–
            renderPathVisualization() {
                this.ctx.strokeStyle = '#00FF00';
                this.ctx.lineWidth = 2;
                
                const aiTanks = this.entityManager.getEntitiesByTag('enemy');
                for (const tank of aiTanks) {
                    const aiController = tank.getComponent('AIController');
                    const transform = tank.getComponent('Transform');
                    
                    if (aiController && transform && aiController.currentPath.length > 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(transform.x, transform.y);
                        
                        for (const point of aiController.currentPath) {
                            this.ctx.lineTo(point.x, point.y);
                        }
                        
                        this.ctx.stroke();
                        
                        // ç»˜åˆ¶è·¯å¾„ç‚¹
                        this.ctx.fillStyle = '#00FF00';
                        for (const point of aiController.currentPath) {
                            this.ctx.beginPath();
                            this.ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }

            // æ¸²æŸ“AIä¿¡æ¯
            renderAIInfo() {
                const aiTanks = this.entityManager.getEntitiesByTag('enemy');
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '12px Arial';
                
                let y = 20;
                for (const tank of aiTanks) {
                    const aiController = tank.getComponent('AIController');
                    const transform = tank.getComponent('Transform');
                    
                    if (aiController && transform) {
                        const status = aiController.getStatus();
                        const text = `${status.behavior}: ${status.state} (${status.visibleEnemies} enemies)`;
                        this.ctx.fillText(text, 10, y);
                        y += 15;
                    }
                }
            }

            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            updateInfo() {
                const aiTanks = this.entityManager.getEntitiesByTag('enemy');
                const playerTanks = this.entityManager.getEntitiesByTag('player');
                
                document.getElementById('aiCount').textContent = aiTanks.length;
                document.getElementById('playerCount').textContent = playerTanks.length;
                
                // æ›´æ–°AIçŠ¶æ€
                this.updateAIStatus();
            }

            // æ›´æ–°AIçŠ¶æ€æ˜¾ç¤º
            updateAIStatus() {
                const statusEl = document.getElementById('aiStatus');
                const aiTanks = this.entityManager.getEntitiesByTag('enemy');
                
                if (aiTanks.length === 0) {
                    statusEl.textContent = 'æ²¡æœ‰AIå¦å…‹';
                    return;
                }
                
                let statusText = '';
                aiTanks.forEach((tank, index) => {
                    const aiController = tank.getComponent('AIController');
                    const transform = tank.getComponent('Transform');
                    const health = tank.getComponent('Health');
                    
                    if (aiController && transform && health) {
                        const status = aiController.getStatus();
                        statusText += `AI${index + 1} [${status.behavior}]: ${status.state}\n`;
                        statusText += `  ä½ç½®: (${Math.round(transform.x)}, ${Math.round(transform.y)})\n`;
                        statusText += `  ç”Ÿå‘½: ${health.currentHealth}/${health.maxHealth}\n`;
                        statusText += `  ç›®æ ‡: ${status.hasTarget ? 'æœ‰' : 'æ— '}\n`;
                        statusText += `  è·¯å¾„: ${status.pathLength}ç‚¹\n`;
                        statusText += `  å¯è§æ•Œäºº: ${status.visibleEnemies}\n\n`;
                    }
                });
                
                statusEl.textContent = statusText;
            }
        }

        // å…¨å±€æµ‹è¯•ç®¡ç†å™¨
        let testManager;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            testManager = new AITestManager();
            console.log('ğŸ§  AIæµ‹è¯•ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        });

        // æµ‹è¯•å‡½æ•°
        function testAIController() {
            try {
                const aiController = new AISystem.AIController(AISystem.AIBehavior.BALANCED);
                
                const hasConfig = aiController.config !== null;
                const correctBehavior = aiController.behavior === AISystem.AIBehavior.BALANCED;
                const hasState = aiController.currentState === AISystem.AIState.IDLE;
                
                const passed = hasConfig && correctBehavior && hasState;
                testManager.addResult('AIæ§åˆ¶å™¨æµ‹è¯•', passed, 
                    passed ? 'AIæ§åˆ¶å™¨åˆ›å»ºæˆåŠŸ' : 'AIæ§åˆ¶å™¨åˆ›å»ºå¤±è´¥');
                return passed;
            } catch (error) {
                testManager.addResult('AIæ§åˆ¶å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testAIBehaviors() {
            try {
                const behaviors = [
                    AISystem.AIBehavior.AGGRESSIVE,
                    AISystem.AIBehavior.DEFENSIVE,
                    AISystem.AIBehavior.BALANCED,
                    AISystem.AIBehavior.COWARD,
                    AISystem.AIBehavior.BERSERKER
                ];
                
                let allConfigsExist = true;
                for (const behavior of behaviors) {
                    if (!AISystem.AIConfig[behavior]) {
                        allConfigsExist = false;
                        break;
                    }
                }
                
                const passed = allConfigsExist && behaviors.length === 5;
                testManager.addResult('AIè¡Œä¸ºç±»å‹æµ‹è¯•', passed,
                    passed ? 'æ‰€æœ‰AIè¡Œä¸ºé…ç½®å®Œæ•´' : 'AIè¡Œä¸ºé…ç½®ç¼ºå¤±');
                return passed;
            } catch (error) {
                testManager.addResult('AIè¡Œä¸ºç±»å‹æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testPathFinding() {
            try {
                const pathFinding = new AISystem.PathFinding(testManager.gameMap);
                
                const path = pathFinding.findPath(50, 50, 200, 200);
                const hasPath = path.length > 0;
                const validPath = path.every(point => 
                    typeof point.x === 'number' && typeof point.y === 'number'
                );
                
                const passed = hasPath && validPath;
                testManager.addResult('è·¯å¾„å¯»æ‰¾æµ‹è¯•', passed,
                    passed ? `æ‰¾åˆ°${path.length}ä¸ªè·¯å¾„ç‚¹` : 'è·¯å¾„å¯»æ‰¾å¤±è´¥');
                return passed;
            } catch (error) {
                testManager.addResult('è·¯å¾„å¯»æ‰¾æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testAIStates() {
            try {
                const states = [
                    AISystem.AIState.IDLE,
                    AISystem.AIState.PATROL,
                    AISystem.AIState.CHASE,
                    AISystem.AIState.ATTACK,
                    AISystem.AIState.RETREAT
                ];
                
                const passed = states.length === 5;
                testManager.addResult('AIçŠ¶æ€æµ‹è¯•', passed,
                    passed ? 'AIçŠ¶æ€æšä¸¾å®Œæ•´' : 'AIçŠ¶æ€æšä¸¾ç¼ºå¤±');
                return passed;
            } catch (error) {
                testManager.addResult('AIçŠ¶æ€æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testAIManager() {
            try {
                const aiManager = new AISystem.AIManager(testManager.entityManager);
                
                // åˆ›å»ºæµ‹è¯•AIå®ä½“
                const tank = new ECS.Entity('TestTank');
                tank.addComponent(new AISystem.AIController());
                
                aiManager.addAI(tank);
                const stats = aiManager.getStats();
                
                const passed = stats.totalAI === 1;
                testManager.addResult('AIç®¡ç†å™¨æµ‹è¯•', passed,
                    passed ? 'AIç®¡ç†å™¨åŠŸèƒ½æ­£å¸¸' : 'AIç®¡ç†å™¨åŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('AIç®¡ç†å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testAIPerception() {
            try {
                const aiController = new AISystem.AIController();
                
                const hasPerceptionMethods = 
                    typeof aiController.updatePerception === 'function' &&
                    typeof aiController.hasLineOfSight === 'function';
                
                const hasPerceptionData = 
                    Array.isArray(aiController.visibleEnemies);
                
                const passed = hasPerceptionMethods && hasPerceptionData;
                testManager.addResult('AIæ„ŸçŸ¥ç³»ç»Ÿæµ‹è¯•', passed,
                    passed ? 'AIæ„ŸçŸ¥ç³»ç»Ÿå®Œæ•´' : 'AIæ„ŸçŸ¥ç³»ç»Ÿç¼ºå¤±');
                return passed;
            } catch (error) {
                testManager.addResult('AIæ„ŸçŸ¥ç³»ç»Ÿæµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        function runAllTests() {
            testManager.clearResults();
            
            const tests = [
                testAIController,
                testAIBehaviors,
                testPathFinding,
                testAIStates,
                testAIManager,
                testAIPerception
            ];
            
            let passedCount = 0;
            tests.forEach(test => {
                if (test()) passedCount++;
            });
            
            const allPassed = passedCount === tests.length;
            testManager.addResult('æ€»ä½“æµ‹è¯•ç»“æœ', allPassed,
                `${passedCount}/${tests.length} ä¸ªæµ‹è¯•é€šè¿‡`);
            
            console.log(`ğŸ§  AIç³»ç»Ÿæµ‹è¯•å®Œæˆ: ${passedCount}/${tests.length} é€šè¿‡`);
        }

        // æ¸…é™¤ç»“æœ
        function clearResults() {
            testManager.clearResults();
        }

        // åˆ›å»ºAIå¦å…‹
        function createAITank(behaviorType) {
            const spawn = testManager.gameMap.getRandomEnemySpawn();
            const tank = testManager.tankManager.createEnemyTank(spawn.x, spawn.y, TankSystem.TankType.ENEMY_BASIC);
            
            const behavior = AISystem.AIBehavior[behaviorType.toUpperCase()];
            const aiController = new AISystem.AIController(behavior);
            
            tank.addComponent(aiController);
            testManager.aiManager.addAI(tank);
            
            console.log('ğŸ§  åˆ›å»ºAIå¦å…‹:', behaviorType);
        }

        // åˆ›å»ºç©å®¶å¦å…‹
        function createPlayerTank() {
            const spawn = testManager.gameMap.getRandomPlayerSpawn();
            testManager.tankManager.createPlayerTank(spawn.x, spawn.y, 1);
            console.log('ğŸš— åˆ›å»ºç©å®¶å¦å…‹');
        }

        // æµ‹è¯•å¯»è·¯
        function testPathfinding() {
            testManager.showPaths = !testManager.showPaths;
            console.log('ğŸ—ºï¸ è·¯å¾„å¯è§†åŒ–:', testManager.showPaths ? 'å¼€å¯' : 'å…³é—­');
        }

        // æ˜¾ç¤ºAIçŠ¶æ€
        function showAIStates() {
            const aiStats = testManager.aiManager.getStats();
            console.log('ğŸ“Š AIç»Ÿè®¡:', aiStats);
            
            let message = `AIå®ä½“æ€»æ•°: ${aiStats.totalAI}\n\n`;
            
            if (aiStats.stateDistribution) {
                message += 'çŠ¶æ€åˆ†å¸ƒ:\n';
                for (const [state, count] of Object.entries(aiStats.stateDistribution)) {
                    message += `  ${state}: ${count}\n`;
                }
            }
            
            if (aiStats.behaviorDistribution) {
                message += '\nè¡Œä¸ºåˆ†å¸ƒ:\n';
                for (const [behavior, count] of Object.entries(aiStats.behaviorDistribution)) {
                    message += `  ${behavior}: ${count}\n`;
                }
            }
            
            alert(message);
        }

        // æ¸…é™¤æ‰€æœ‰
        function clearAll() {
            testManager.tankManager.clearAll();
            testManager.aiManager.clearAll();
            testManager.fireSystem.clearAll();
            
            // æ¸…é™¤çˆ†ç‚¸æ•ˆæœ
            const explosions = testManager.entityManager.getEntitiesByTag('explosion');
            explosions.forEach(explosion => {
                testManager.entityManager.removeEntity(explosion);
            });
            
            console.log('ğŸ§¹ æ¸…é™¤æ‰€æœ‰å®ä½“');
        }
    </script>
</body>
</html>