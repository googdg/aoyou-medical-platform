<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ˜æ–—ç³»ç»Ÿæµ‹è¯• - Combat System Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        #combatCanvas {
            border: 2px solid #333;
            background: #000;
        }
        .controls {
            margin: 10px 0;
        }
        .combat-info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .combat-stats {
            font-family: monospace;
            font-size: 12px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .damage-types {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .damage-sample {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .damage-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>âš”ï¸ æˆ˜æ–—ç³»ç»Ÿæµ‹è¯•</h1>
    
    <div class="test-container">
        <h2>ğŸ“‹ æµ‹è¯•ç»“æœ</h2>
        <div id="testResults"></div>
        <button onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
        <button onclick="clearResults()">ğŸ§¹ æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="test-container">
        <h2>ğŸ® æˆ˜æ–—å¯è§†åŒ–æµ‹è¯•</h2>
        <canvas id="combatCanvas" width="800" height="600"></canvas>
        <div class="controls">
            <button onclick="createTestTanks()">ğŸš— åˆ›å»ºæµ‹è¯•å¦å…‹</button>
            <button onclick="testTankCollision()">ğŸ’¥ æµ‹è¯•å¦å…‹ç¢°æ’</button>
            <button onclick="testBulletDamage()">ğŸ¯ æµ‹è¯•å­å¼¹ä¼¤å®³</button>
            <button onclick="testExplosionDamage()">ğŸ’£ æµ‹è¯•çˆ†ç‚¸ä¼¤å®³</button>
            <button onclick="showDamageNumbers()">ğŸ”¢ æ˜¾ç¤ºä¼¤å®³æ•°å­—</button>
        </div>
        <div class="controls">
            <button onclick="testSpatialGrid()">ğŸ—‚ï¸ æµ‹è¯•ç©ºé—´ç½‘æ ¼</button>
            <button onclick="testCollisionDetection()">ğŸ” æµ‹è¯•ç¢°æ’æ£€æµ‹</button>
            <button onclick="resetCombatStats()">ğŸ“Š é‡ç½®ç»Ÿè®¡</button>
            <button onclick="clearAll()">ğŸ§¹ æ¸…é™¤æ‰€æœ‰</button>
        </div>
        <div class="controls">
            <p><strong>è¯´æ˜ï¼š</strong> åˆ›å»ºå¦å…‹åå¯ä»¥æµ‹è¯•å„ç§æˆ˜æ–—åŠŸèƒ½</p>
        </div>
    </div>

    <div class="test-container">
        <h2>ğŸ“Š æˆ˜æ–—ä¿¡æ¯</h2>
        <div class="combat-info" id="combatInfo">
            <p>å¦å…‹æ•°é‡: <span id="tankCount">0</span></p>
            <p>å­å¼¹æ•°é‡: <span id="bulletCount">0</span></p>
            <p>ä¼¤å®³æ•°å­—: <span id="damageNumberCount">0</span></p>
        </div>
        
        <h3>ä¼¤å®³ç±»å‹</h3>
        <div class="damage-types">
            <div class="damage-sample">
                <div class="damage-color" style="background: #FFD700;"></div>
                <span>å­å¼¹ä¼¤å®³</span>
            </div>
            <div class="damage-sample">
                <div class="damage-color" style="background: #FF4500;"></div>
                <span>çˆ†ç‚¸ä¼¤å®³</span>
            </div>
            <div class="damage-sample">
                <div class="damage-color" style="background: #FFFFFF;"></div>
                <span>ç¢°æ’ä¼¤å®³</span>
            </div>
            <div class="damage-sample">
                <div class="damage-color" style="background: #FF0000;"></div>
                <span>ç¯å¢ƒä¼¤å®³</span>
            </div>
        </div>
        
        <h3>æˆ˜æ–—ç»Ÿè®¡</h3>
        <div class="combat-stats" id="combatStats">
            ç­‰å¾…æˆ˜æ–—æ•°æ®...
        </div>
    </div>

    <!-- å¼•å…¥ä¾èµ– -->
    <script src="../js/entity-component-system.js"></script>
    <script src="../js/map-system.js"></script>
    <script src="../js/tank-system.js"></script>
    <script src="../js/bullet-system.js"></script>
    <script src="../js/ai-system.js"></script>
    <script src="../js/combat-system.js"></script>
    
    <script>
        // æµ‹è¯•ç®¡ç†å™¨
        class CombatTestManager {
            constructor() {
                this.results = [];
                this.entityManager = new ECS.EntityManager();
                this.tankManager = new TankSystem.TankManager(this.entityManager);
                this.fireSystem = new BulletSystem.FireSystem();
                this.combatManager = new CombatSystem.CombatManager(this.entityManager);
                this.damageNumberSystem = new CombatSystem.DamageNumberSystem();
                this.canvas = document.getElementById('combatCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                // åˆ›å»ºç®€å•åœ°å›¾
                this.gameMap = new MapSystem.GameMap(25, 19, 32);
                this.setupTestMap();
                
                // è®¾ç½®å…¨å±€å¼•ç”¨
                window.game = {
                    entityManager: this.entityManager,
                    canvas: this.canvas,
                    currentMap: this.gameMap,
                    inputManager: { isKeyDown: () => false, isKeyPressed: () => false },
                    createBullet: (bulletData) => this.createBullet(bulletData),
                    createExplosion: (x, y, radius) => this.createExplosion(x, y, radius),
                    onPlayerTankDestroyed: (tank) => console.log('ç©å®¶å¦å…‹è¢«æ‘§æ¯'),
                    onEnemyTankDestroyed: (tank) => console.log('æ•Œæ–¹å¦å…‹è¢«æ‘§æ¯')
                };
                
                this.setupCombatEventListeners();
                this.startRenderLoop();
            }

            setupTestMap() {
                // åˆ›å»ºè¾¹æ¡†
                this.gameMap.drawBorder(MapSystem.TileType.STEEL);
                
                // æ·»åŠ ä¸€äº›éšœç¢ç‰©
                for (let i = 0; i < 10; i++) {
                    const x = Math.floor(Math.random() * (this.gameMap.width - 4)) + 2;
                    const y = Math.floor(Math.random() * (this.gameMap.height - 4)) + 2;
                    this.gameMap.setTile(x, y, MapSystem.TileType.BRICK);
                }
            }

            setupCombatEventListeners() {
                // ç›‘å¬ä¼¤å®³äº‹ä»¶
                this.combatManager.addEventListener(CombatSystem.CombatEvent.DAMAGE_DEALT, (data) => {
                    const transform = data.target.getComponent('Transform');
                    if (transform) {
                        this.damageNumberSystem.showDamage(
                            transform.x, 
                            transform.y - 20, 
                            data.damage, 
                            data.damageType
                        );
                    }
                    console.log('ğŸ’¥ ä¼¤å®³äº‹ä»¶:', data.damage, data.damageType);
                });
                
                // ç›‘å¬å…¶ä»–æˆ˜æ–—äº‹ä»¶
                this.combatManager.addEventListener(CombatSystem.CombatEvent.TANK_DESTROYED, (data) => {
                    console.log('ğŸ”¥ å¦å…‹æ‘§æ¯äº‹ä»¶');
                });
                
                this.combatManager.addEventListener(CombatSystem.CombatEvent.COLLISION_OCCURRED, (data) => {
                    console.log('ğŸ’¥ ç¢°æ’äº‹ä»¶:', data.type);
                });
            }

            createBullet(bulletData) {
                const bullet = this.fireSystem.createBullet(bulletData);
                this.entityManager.addEntity(bullet);
                
                // ç®€å•çš„è¾¹ç•Œæ£€æŸ¥
                const originalUpdate = bullet.update.bind(bullet);
                bullet.update = (deltaTime) => {
                    originalUpdate(deltaTime);
                    
                    const transform = bullet.getComponent('Transform');
                    if (transform) {
                        if (transform.x < 0 || transform.x > this.canvas.width ||
                            transform.y < 0 || transform.y > this.canvas.height) {
                            this.entityManager.removeEntity(bullet);
                        }
                    }
                };
                
                return bullet;
            }

            createExplosion(x, y, radius = 50) {
                const explosion = new ECS.Entity('Explosion');
                explosion.addComponent(new ECS.Transform(x, y, 0));
                explosion.addComponent(new BulletSystem.Explosion(radius, 1000));
                explosion.addComponent(new BulletSystem.ExplosionRenderer());
                explosion.addTag('explosion');
                this.entityManager.addEntity(explosion);
                return explosion;
            }

            // æ·»åŠ æµ‹è¯•ç»“æœ
            addResult(testName, passed, message = '') {
                this.results.push({
                    name: testName,
                    passed: passed,
                    message: message,
                    timestamp: new Date().toLocaleTimeString()
                });
                this.updateResultsDisplay();
            }

            // æ›´æ–°ç»“æœæ˜¾ç¤º
            updateResultsDisplay() {
                const container = document.getElementById('testResults');
                container.innerHTML = '';
                
                this.results.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                    div.innerHTML = `
                        <strong>${result.passed ? 'âœ…' : 'âŒ'} ${result.name}</strong>
                        <br><small>${result.timestamp}</small>
                        ${result.message ? `<br>${result.message}` : ''}
                    `;
                    container.appendChild(div);
                });
            }

            // æ¸…é™¤ç»“æœ
            clearResults() {
                this.results = [];
                this.updateResultsDisplay();
            }

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            startRenderLoop() {
                const render = () => {
                    this.update();
                    this.render();
                    this.updateInfo();
                    requestAnimationFrame(render);
                };
                render();
            }

            // æ›´æ–°
            update() {
                this.entityManager.update(16);
                this.fireSystem.update(16);
                this.combatManager.update(16);
                this.damageNumberSystem.update(16);
            }

            // æ¸²æŸ“
            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // æ¸²æŸ“åœ°å›¾
                this.gameMap.render(this.ctx);
                
                // æ¸²æŸ“æ‰€æœ‰å®ä½“
                this.entityManager.render(this.ctx);
                
                // æ¸²æŸ“ä¼¤å®³æ•°å­—
                this.damageNumberSystem.render(this.ctx);
                
                // æ¸²æŸ“ç¢°æ’ä¿¡æ¯
                this.renderCollisionInfo();
            }

            // æ¸²æŸ“ç¢°æ’ä¿¡æ¯
            renderCollisionInfo() {
                const collisions = this.combatManager.collisionDetector.collisionPairs;
                
                this.ctx.strokeStyle = '#FF0000';
                this.ctx.lineWidth = 2;
                
                for (const collision of collisions) {
                    const transformA = collision.entityA.getComponent('Transform');
                    const transformB = collision.entityB.getComponent('Transform');
                    
                    if (transformA && transformB) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(transformA.x, transformA.y);
                        this.ctx.lineTo(transformB.x, transformB.y);
                        this.ctx.stroke();
                    }
                }
            }

            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            updateInfo() {
                const tanks = this.entityManager.getEntitiesByTag('tank');
                const bullets = this.entityManager.getEntitiesByTag('bullet');
                
                document.getElementById('tankCount').textContent = tanks.length;
                document.getElementById('bulletCount').textContent = bullets.length;
                document.getElementById('damageNumberCount').textContent = this.damageNumberSystem.damageNumbers.length;
                
                // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡
                this.updateCombatStats();
            }

            // æ›´æ–°æˆ˜æ–—ç»Ÿè®¡æ˜¾ç¤º
            updateCombatStats() {
                const statsEl = document.getElementById('combatStats');
                const stats = this.combatManager.getStats();
                const recentEvents = this.combatManager.getRecentEvents(5);
                
                let statsText = `æ€»ä¼¤å®³: ${stats.totalDamageDealt}\n`;
                statsText += `å¦å…‹æ‘§æ¯: ${stats.tanksDestroyed}\n`;
                statsText += `å­å¼¹å‡»ä¸­: ${stats.bulletsHit}\n`;
                statsText += `çˆ†ç‚¸æ¬¡æ•°: ${stats.explosions}\n`;
                statsText += `ç¢°æ’æ¬¡æ•°: ${stats.collisions}\n\n`;
                
                statsText += 'æœ€è¿‘äº‹ä»¶:\n';
                recentEvents.forEach((event, index) => {
                    const time = new Date(event.timestamp).toLocaleTimeString();
                    statsText += `${index + 1}. [${time}] ${event.type}\n`;
                });
                
                statsEl.textContent = statsText;
            }
        }

        // å…¨å±€æµ‹è¯•ç®¡ç†å™¨
        let testManager;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            testManager = new CombatTestManager();
            console.log('âš”ï¸ æˆ˜æ–—æµ‹è¯•ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        });

        // æµ‹è¯•å‡½æ•°
        function testCombatManager() {
            try {
                const combatManager = new CombatSystem.CombatManager(testManager.entityManager);
                
                const hasCollisionDetector = combatManager.collisionDetector !== null;
                const hasStats = typeof combatManager.getStats === 'function';
                const hasEventSystem = typeof combatManager.addEventListener === 'function';
                
                const passed = hasCollisionDetector && hasStats && hasEventSystem;
                testManager.addResult('æˆ˜æ–—ç®¡ç†å™¨æµ‹è¯•', passed, 
                    passed ? 'æˆ˜æ–—ç®¡ç†å™¨åˆ›å»ºæˆåŠŸ' : 'æˆ˜æ–—ç®¡ç†å™¨åˆ›å»ºå¤±è´¥');
                return passed;
            } catch (error) {
                testManager.addResult('æˆ˜æ–—ç®¡ç†å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testCollisionDetector() {
            try {
                const detector = new CombatSystem.AdvancedCollisionDetector();
                
                const hasSpatialGrid = detector.spatialGrid !== null;
                const hasDetectMethod = typeof detector.detectCollisions === 'function';
                const hasPreciseCheck = typeof detector.preciseCollisionCheck === 'function';
                
                const passed = hasSpatialGrid && hasDetectMethod && hasPreciseCheck;
                testManager.addResult('ç¢°æ’æ£€æµ‹å™¨æµ‹è¯•', passed,
                    passed ? 'ç¢°æ’æ£€æµ‹å™¨åŠŸèƒ½å®Œæ•´' : 'ç¢°æ’æ£€æµ‹å™¨åŠŸèƒ½ç¼ºå¤±');
                return passed;
            } catch (error) {
                testManager.addResult('ç¢°æ’æ£€æµ‹å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testSpatialGridSystem() {
            try {
                const grid = new CombatSystem.SpatialGrid(64);
                
                // åˆ›å»ºæµ‹è¯•å®ä½“
                const entity = new ECS.Entity('TestEntity');
                entity.addComponent(new ECS.Transform(100, 100));
                entity.addComponent(new ECS.Collider(32, 32));
                
                grid.insert(entity, 100, 100, 32, 32);
                const nearby = grid.getNearby(entity);
                
                const passed = Array.isArray(nearby);
                testManager.addResult('ç©ºé—´ç½‘æ ¼æµ‹è¯•', passed,
                    passed ? 'ç©ºé—´ç½‘æ ¼åŠŸèƒ½æ­£å¸¸' : 'ç©ºé—´ç½‘æ ¼åŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ç©ºé—´ç½‘æ ¼æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testDamageSystem() {
            try {
                const combatManager = new CombatSystem.CombatManager(testManager.entityManager);
                
                // åˆ›å»ºæµ‹è¯•å¦å…‹
                const tank = new ECS.Entity('TestTank');
                tank.addComponent(new ECS.Transform(100, 100));
                tank.addComponent(new ECS.Health(3));
                
                // æµ‹è¯•ä¼¤å®³
                const damaged = combatManager.dealDamage(tank, 1, CombatSystem.DamageType.BULLET);
                const health = tank.getComponent('Health');
                
                const passed = damaged && health.currentHealth === 2;
                testManager.addResult('ä¼¤å®³ç³»ç»Ÿæµ‹è¯•', passed,
                    passed ? 'ä¼¤å®³ç³»ç»ŸåŠŸèƒ½æ­£å¸¸' : 'ä¼¤å®³ç³»ç»ŸåŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ä¼¤å®³ç³»ç»Ÿæµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testDamageNumbers() {
            try {
                const damageSystem = new CombatSystem.DamageNumberSystem();
                
                damageSystem.showDamage(100, 100, 50, CombatSystem.DamageType.BULLET);
                const hasNumbers = damageSystem.damageNumbers.length > 0;
                
                damageSystem.update(16);
                const canUpdate = typeof damageSystem.update === 'function';
                
                const passed = hasNumbers && canUpdate;
                testManager.addResult('ä¼¤å®³æ•°å­—æµ‹è¯•', passed,
                    passed ? 'ä¼¤å®³æ•°å­—ç³»ç»Ÿæ­£å¸¸' : 'ä¼¤å®³æ•°å­—ç³»ç»Ÿå¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ä¼¤å®³æ•°å­—æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testCombatEvents() {
            try {
                const combatManager = new CombatSystem.CombatManager(testManager.entityManager);
                
                let eventTriggered = false;
                combatManager.addEventListener(CombatSystem.CombatEvent.DAMAGE_DEALT, () => {
                    eventTriggered = true;
                });
                
                // è§¦å‘äº‹ä»¶
                combatManager.addCombatEvent(CombatSystem.CombatEvent.DAMAGE_DEALT, { damage: 10 });
                
                const passed = eventTriggered;
                testManager.addResult('æˆ˜æ–—äº‹ä»¶æµ‹è¯•', passed,
                    passed ? 'æˆ˜æ–—äº‹ä»¶ç³»ç»Ÿæ­£å¸¸' : 'æˆ˜æ–—äº‹ä»¶ç³»ç»Ÿå¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('æˆ˜æ–—äº‹ä»¶æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        function runAllTests() {
            testManager.clearResults();
            
            const tests = [
                testCombatManager,
                testCollisionDetector,
                testSpatialGridSystem,
                testDamageSystem,
                testDamageNumbers,
                testCombatEvents
            ];
            
            let passedCount = 0;
            tests.forEach(test => {
                if (test()) passedCount++;
            });
            
            const allPassed = passedCount === tests.length;
            testManager.addResult('æ€»ä½“æµ‹è¯•ç»“æœ', allPassed,
                `${passedCount}/${tests.length} ä¸ªæµ‹è¯•é€šè¿‡`);
            
            console.log(`âš”ï¸ æˆ˜æ–—ç³»ç»Ÿæµ‹è¯•å®Œæˆ: ${passedCount}/${tests.length} é€šè¿‡`);
        }

        // æ¸…é™¤ç»“æœ
        function clearResults() {
            testManager.clearResults();
        }

        // åˆ›å»ºæµ‹è¯•å¦å…‹
        function createTestTanks() {
            // åˆ›å»ºç©å®¶å¦å…‹
            const playerTank = testManager.tankManager.createPlayerTank(200, 300, 1);
            
            // åˆ›å»ºæ•Œæ–¹å¦å…‹
            const enemyTank = testManager.tankManager.createEnemyTank(600, 300, TankSystem.TankType.ENEMY_BASIC);
            
            console.log('ğŸš— åˆ›å»ºæµ‹è¯•å¦å…‹');
        }

        // æµ‹è¯•å¦å…‹ç¢°æ’
        function testTankCollision() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length < 2) {
                alert('éœ€è¦è‡³å°‘2ä¸ªå¦å…‹æ¥æµ‹è¯•ç¢°æ’');
                return;
            }
            
            // å°†ä¸¤ä¸ªå¦å…‹ç§»åŠ¨åˆ°ç›¸è¿‘ä½ç½®
            const tank1 = tanks[0];
            const tank2 = tanks[1];
            
            const transform1 = tank1.getComponent('Transform');
            const transform2 = tank2.getComponent('Transform');
            
            if (transform1 && transform2) {
                transform2.setPosition(transform1.x + 25, transform1.y);
                console.log('ğŸ’¥ å¼ºåˆ¶å¦å…‹ç¢°æ’');
            }
        }

        // æµ‹è¯•å­å¼¹ä¼¤å®³
        function testBulletDamage() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºå¦å…‹');
                return;
            }
            
            const tank = tanks[0];
            const transform = tank.getComponent('Transform');
            
            if (transform) {
                // åˆ›å»ºå­å¼¹å‡»ä¸­å¦å…‹
                const bullet = testManager.createBullet({
                    x: transform.x - 50,
                    y: transform.y,
                    velocityX: 300,
                    velocityY: 0,
                    type: BulletSystem.BulletType.NORMAL,
                    damage: 25
                });
                
                console.log('ğŸ¯ å‘å°„å­å¼¹æµ‹è¯•ä¼¤å®³');
            }
        }

        // æµ‹è¯•çˆ†ç‚¸ä¼¤å®³
        function testExplosionDamage() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºå¦å…‹');
                return;
            }
            
            const tank = tanks[0];
            const transform = tank.getComponent('Transform');
            
            if (transform) {
                // åœ¨å¦å…‹é™„è¿‘åˆ›å»ºçˆ†ç‚¸
                testManager.createExplosion(transform.x + 30, transform.y, 80);
                
                // æ‰‹åŠ¨é€ æˆçˆ†ç‚¸ä¼¤å®³
                testManager.combatManager.dealDamage(tank, 30, CombatSystem.DamageType.EXPLOSION);
                
                console.log('ğŸ’£ æµ‹è¯•çˆ†ç‚¸ä¼¤å®³');
            }
        }

        // æ˜¾ç¤ºä¼¤å®³æ•°å­—
        function showDamageNumbers() {
            for (let i = 0; i < 5; i++) {
                const x = 200 + Math.random() * 400;
                const y = 200 + Math.random() * 200;
                const damage = Math.floor(Math.random() * 50) + 10;
                const types = [
                    CombatSystem.DamageType.BULLET,
                    CombatSystem.DamageType.EXPLOSION,
                    CombatSystem.DamageType.COLLISION
                ];
                const type = types[Math.floor(Math.random() * types.length)];
                
                testManager.damageNumberSystem.showDamage(x, y, damage, type);
            }
            
            console.log('ğŸ”¢ æ˜¾ç¤ºéšæœºä¼¤å®³æ•°å­—');
        }

        // æµ‹è¯•ç©ºé—´ç½‘æ ¼
        function testSpatialGrid() {
            const detector = testManager.combatManager.collisionDetector;
            const entities = Array.from(testManager.entityManager.entities.values());
            
            detector.updateSpatialGrid(entities);
            
            console.log('ğŸ—‚ï¸ ç©ºé—´ç½‘æ ¼å·²æ›´æ–°ï¼Œå®ä½“æ•°é‡:', entities.length);
        }

        // æµ‹è¯•ç¢°æ’æ£€æµ‹
        function testCollisionDetection() {
            const entities = Array.from(testManager.entityManager.entities.values());
            const collisions = testManager.combatManager.collisionDetector.detectCollisions(entities);
            
            console.log('ğŸ” ç¢°æ’æ£€æµ‹å®Œæˆï¼Œå‘ç°', collisions.length, 'ä¸ªç¢°æ’');
        }

        // é‡ç½®æˆ˜æ–—ç»Ÿè®¡
        function resetCombatStats() {
            testManager.combatManager.resetStats();
            console.log('ğŸ“Š æˆ˜æ–—ç»Ÿè®¡å·²é‡ç½®');
        }

        // æ¸…é™¤æ‰€æœ‰
        function clearAll() {
            testManager.tankManager.clearAll();
            testManager.fireSystem.clearAll();
            testManager.damageNumberSystem.clear();
            
            // æ¸…é™¤çˆ†ç‚¸æ•ˆæœ
            const explosions = testManager.entityManager.getEntitiesByTag('explosion');
            explosions.forEach(explosion => {
                testManager.entityManager.removeEntity(explosion);
            });
            
            console.log('ğŸ§¹ æ¸…é™¤æ‰€æœ‰å®ä½“');
        }
    </script>
</body>
</html>