<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ°å›¾ç³»ç»Ÿæµ‹è¯• - Map System Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        #mapCanvas {
            border: 2px solid #333;
            background: #000;
        }
        .controls {
            margin: 10px 0;
        }
        .map-info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .tile-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .tile-sample {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .tile-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>ğŸ—ºï¸ åœ°å›¾ç³»ç»Ÿæµ‹è¯•</h1>
    
    <div class="test-container">
        <h2>ğŸ“‹ æµ‹è¯•ç»“æœ</h2>
        <div id="testResults"></div>
        <button onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
        <button onclick="clearResults()">ğŸ§¹ æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="test-container">
        <h2>ğŸ® åœ°å›¾å¯è§†åŒ–</h2>
        <canvas id="mapCanvas" width="832" height="832"></canvas>
        <div class="controls">
            <button onclick="loadMap('test')">ğŸ§ª æµ‹è¯•åœ°å›¾</button>
            <button onclick="loadMap('classic')">ğŸ›ï¸ ç»å…¸åœ°å›¾</button>
            <button onclick="loadMap('maze')">ğŸŒ€ è¿·å®«åœ°å›¾</button>
            <button onclick="createRandomMap()">ğŸ² éšæœºåœ°å›¾</button>
            <button onclick="clearMap()">ğŸ§¹ æ¸…ç©ºåœ°å›¾</button>
        </div>
        <div class="controls">
            <button onclick="testCollision()">ğŸ’¥ æµ‹è¯•ç¢°æ’</button>
            <button onclick="testDestruction()">ğŸ’£ æµ‹è¯•ç ´å</button>
            <button onclick="showSpawnPoints()">ğŸ“ æ˜¾ç¤ºç”Ÿæˆç‚¹</button>
        </div>
    </div>

    <div class="test-container">
        <h2>ğŸ“Š åœ°å›¾ä¿¡æ¯</h2>
        <div class="map-info" id="mapInfo">
            <p>å½“å‰åœ°å›¾: æ— </p>
        </div>
        
        <h3>ç“¦ç‰‡å›¾ä¾‹</h3>
        <div class="tile-legend">
            <div class="tile-sample">
                <div class="tile-color" style="background: #000000;"></div>
                <span>ç©ºåœ°</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #CD853F;"></div>
                <span>ç –å¢™</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #C0C0C0;"></div>
                <span>é’¢å¢™</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #4169E1;"></div>
                <span>æ°´åŸŸ</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #228B22;"></div>
                <span>è‰åœ°</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #FFD700;"></div>
                <span>åŸºåœ°</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #00FF00;"></div>
                <span>ç©å®¶ç”Ÿæˆç‚¹</span>
            </div>
            <div class="tile-sample">
                <div class="tile-color" style="background: #FF0000;"></div>
                <span>æ•Œäººç”Ÿæˆç‚¹</span>
            </div>
        </div>
    </div>

    <!-- å¼•å…¥åœ°å›¾ç³»ç»Ÿ -->
    <script src="../js/map-system.js"></script>
    
    <script>
        // æµ‹è¯•ç®¡ç†å™¨
        class MapTestManager {
            constructor() {
                this.results = [];
                this.mapManager = new MapSystem.MapManager();
                this.currentMap = null;
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                // æµ‹è¯•ç‚¹
                this.testPoints = [];
                this.showingSpawns = false;
                
                this.initCanvas();
            }

            initCanvas() {
                // è®¾ç½®ç”»å¸ƒç‚¹å‡»äº‹ä»¶
                this.canvas.addEventListener('click', (e) => {
                    if (this.currentMap) {
                        const rect = this.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        this.handleCanvasClick(x, y);
                    }
                });
            }

            handleCanvasClick(x, y) {
                if (!this.currentMap) return;
                
                const tilePos = this.currentMap.worldToTile(x, y);
                const tile = this.currentMap.getTile(tilePos.x, tilePos.y);
                
                if (tile) {
                    console.log(`ç‚¹å‡»ç“¦ç‰‡: (${tilePos.x}, ${tilePos.y}), ç±»å‹: ${tile.config.name}`);
                    
                    // æµ‹è¯•ç ´å
                    if (tile.isDestructible()) {
                        this.currentMap.destroyTile(x, y);
                        this.renderMap();
                    }
                }
            }

            // æ·»åŠ æµ‹è¯•ç»“æœ
            addResult(testName, passed, message = '') {
                this.results.push({
                    name: testName,
                    passed: passed,
                    message: message,
                    timestamp: new Date().toLocaleTimeString()
                });
                this.updateResultsDisplay();
            }

            // æ›´æ–°ç»“æœæ˜¾ç¤º
            updateResultsDisplay() {
                const container = document.getElementById('testResults');
                container.innerHTML = '';
                
                this.results.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                    div.innerHTML = `
                        <strong>${result.passed ? 'âœ…' : 'âŒ'} ${result.name}</strong>
                        <br><small>${result.timestamp}</small>
                        ${result.message ? `<br>${result.message}` : ''}
                    `;
                    container.appendChild(div);
                });
            }

            // æ¸…é™¤ç»“æœ
            clearResults() {
                this.results = [];
                this.updateResultsDisplay();
            }

            // æ¸²æŸ“åœ°å›¾
            renderMap() {
                if (!this.currentMap) {
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.font = '24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('æ²¡æœ‰åŠ è½½åœ°å›¾', this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.textAlign = 'left';
                    return;
                }
                
                // æ¸²æŸ“åœ°å›¾
                this.currentMap.render(this.ctx);
                
                // æ¸²æŸ“æµ‹è¯•ç‚¹
                this.renderTestPoints();
                
                // æ¸²æŸ“ç”Ÿæˆç‚¹ï¼ˆå¦‚æœæ˜¾ç¤ºï¼‰
                if (this.showingSpawns) {
                    this.renderSpawnPoints();
                }
                
                // æ›´æ–°åœ°å›¾ä¿¡æ¯
                this.updateMapInfo();
            }

            // æ¸²æŸ“æµ‹è¯•ç‚¹
            renderTestPoints() {
                this.ctx.fillStyle = '#FF00FF';
                this.testPoints.forEach(point => {
                    this.ctx.fillRect(point.x - 2, point.y - 2, 4, 4);
                });
            }

            // æ¸²æŸ“ç”Ÿæˆç‚¹
            renderSpawnPoints() {
                // ç©å®¶ç”Ÿæˆç‚¹
                this.ctx.fillStyle = '#00FF00';
                this.currentMap.playerSpawns.forEach(spawn => {
                    this.ctx.beginPath();
                    this.ctx.arc(spawn.x, spawn.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('P', spawn.x, spawn.y + 4);
                    this.ctx.fillStyle = '#00FF00';
                });
                
                // æ•Œäººç”Ÿæˆç‚¹
                this.ctx.fillStyle = '#FF0000';
                this.currentMap.enemySpawns.forEach(spawn => {
                    this.ctx.beginPath();
                    this.ctx.arc(spawn.x, spawn.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('E', spawn.x, spawn.y + 4);
                    this.ctx.fillStyle = '#FF0000';
                });
                
                // åŸºåœ°
                if (this.currentMap.basePosition) {
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.arc(this.currentMap.basePosition.x, this.currentMap.basePosition.y, 12, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#000';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('B', this.currentMap.basePosition.x, this.currentMap.basePosition.y + 4);
                }
                
                this.ctx.textAlign = 'left';
            }

            // æ›´æ–°åœ°å›¾ä¿¡æ¯
            updateMapInfo() {
                const infoEl = document.getElementById('mapInfo');
                if (!this.currentMap) {
                    infoEl.innerHTML = '<p>å½“å‰åœ°å›¾: æ— </p>';
                    return;
                }
                
                let tileCount = {};
                for (let y = 0; y < this.currentMap.height; y++) {
                    for (let x = 0; x < this.currentMap.width; x++) {
                        const tile = this.currentMap.getTile(x, y);
                        const typeName = tile.config.name;
                        tileCount[typeName] = (tileCount[typeName] || 0) + 1;
                    }
                }
                
                let html = `
                    <p><strong>åœ°å›¾å°ºå¯¸:</strong> ${this.currentMap.width} x ${this.currentMap.height}</p>
                    <p><strong>ç“¦ç‰‡å¤§å°:</strong> ${this.currentMap.tileSize}px</p>
                    <p><strong>åƒç´ å°ºå¯¸:</strong> ${this.currentMap.pixelWidth} x ${this.currentMap.pixelHeight}</p>
                    <p><strong>ç©å®¶ç”Ÿæˆç‚¹:</strong> ${this.currentMap.playerSpawns.length}ä¸ª</p>
                    <p><strong>æ•Œäººç”Ÿæˆç‚¹:</strong> ${this.currentMap.enemySpawns.length}ä¸ª</p>
                    <p><strong>åŸºåœ°:</strong> ${this.currentMap.basePosition ? 'æœ‰' : 'æ— '}</p>
                    <p><strong>ç“¦ç‰‡ç»Ÿè®¡:</strong></p>
                    <ul>
                `;
                
                for (const [type, count] of Object.entries(tileCount)) {
                    html += `<li>${type}: ${count}ä¸ª</li>`;
                }
                
                html += '</ul>';
                infoEl.innerHTML = html;
            }
        }

        // å…¨å±€æµ‹è¯•ç®¡ç†å™¨
        let testManager;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            testManager = new MapTestManager();
            console.log('ğŸ—ºï¸ åœ°å›¾æµ‹è¯•ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        });

        // æµ‹è¯•å‡½æ•°
        function testMapCreation() {
            try {
                const map = new MapSystem.GameMap(10, 10, 32);
                const passed = map.width === 10 && map.height === 10 && map.tileSize === 32;
                testManager.addResult('åœ°å›¾åˆ›å»ºæµ‹è¯•', passed, 
                    passed ? 'åœ°å›¾åˆ›å»ºæˆåŠŸ' : 'åœ°å›¾åˆ›å»ºå¤±è´¥');
                return passed;
            } catch (error) {
                testManager.addResult('åœ°å›¾åˆ›å»ºæµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTileOperations() {
            try {
                const map = new MapSystem.GameMap(5, 5, 32);
                
                // æµ‹è¯•è®¾ç½®ç“¦ç‰‡
                const setResult = map.setTile(2, 2, MapSystem.TileType.BRICK);
                const tile = map.getTile(2, 2);
                const getResult = tile && tile.type === MapSystem.TileType.BRICK;
                
                // æµ‹è¯•åæ ‡è½¬æ¢
                const worldPos = map.tileToWorld(2, 2);
                const tilePos = map.worldToTile(worldPos.x, worldPos.y);
                const coordResult = tilePos.x === 2 && tilePos.y === 2;
                
                const passed = setResult && getResult && coordResult;
                testManager.addResult('ç“¦ç‰‡æ“ä½œæµ‹è¯•', passed,
                    passed ? 'ç“¦ç‰‡è®¾ç½®å’Œåæ ‡è½¬æ¢æ­£å¸¸' : 'ç“¦ç‰‡æ“ä½œå¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ç“¦ç‰‡æ“ä½œæµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testCollisionDetection() {
            try {
                const map = new MapSystem.GameMap(5, 5, 32);
                map.setTile(2, 2, MapSystem.TileType.STEEL);
                
                const worldPos = map.tileToWorld(2, 2);
                const passable1 = map.isPassable(worldPos.x, worldPos.y);
                const passable2 = map.isPassable(16, 16); // ç©ºåœ°
                
                const rectPassable1 = map.isRectPassable(worldPos.x, worldPos.y, 30, 30);
                const rectPassable2 = map.isRectPassable(16, 16, 30, 30);
                
                const passed = !passable1 && passable2 && !rectPassable1 && rectPassable2;
                testManager.addResult('ç¢°æ’æ£€æµ‹æµ‹è¯•', passed,
                    passed ? 'ç¢°æ’æ£€æµ‹åŠŸèƒ½æ­£å¸¸' : 'ç¢°æ’æ£€æµ‹åŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ç¢°æ’æ£€æµ‹æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTileDestruction() {
            try {
                const map = new MapSystem.GameMap(5, 5, 32);
                map.setTile(2, 2, MapSystem.TileType.BRICK);
                
                const worldPos = map.tileToWorld(2, 2);
                const destroyed = map.destroyTile(worldPos.x, worldPos.y);
                const tile = map.getTile(2, 2);
                
                const passed = destroyed && tile.type === MapSystem.TileType.EMPTY;
                testManager.addResult('ç“¦ç‰‡ç ´åæµ‹è¯•', passed,
                    passed ? 'ç“¦ç‰‡ç ´ååŠŸèƒ½æ­£å¸¸' : 'ç“¦ç‰‡ç ´ååŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ç“¦ç‰‡ç ´åæµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testMapManager() {
            try {
                const manager = new MapSystem.MapManager();
                const mapList = manager.getMapList();
                const hasTestMap = mapList.includes('test');
                
                const testMap = manager.loadMap('test');
                const loadResult = testMap !== null;
                
                const passed = hasTestMap && loadResult;
                testManager.addResult('åœ°å›¾ç®¡ç†å™¨æµ‹è¯•', passed,
                    passed ? 'åœ°å›¾ç®¡ç†å™¨åŠŸèƒ½æ­£å¸¸' : 'åœ°å›¾ç®¡ç†å™¨åŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('åœ°å›¾ç®¡ç†å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testSpawnPoints() {
            try {
                const manager = new MapSystem.MapManager();
                const map = manager.loadMap('test');
                
                const playerSpawn = map.getRandomPlayerSpawn();
                const enemySpawn = map.getRandomEnemySpawn();
                
                const passed = playerSpawn && enemySpawn && 
                              typeof playerSpawn.x === 'number' && 
                              typeof enemySpawn.x === 'number';
                
                testManager.addResult('ç”Ÿæˆç‚¹æµ‹è¯•', passed,
                    passed ? 'ç”Ÿæˆç‚¹åŠŸèƒ½æ­£å¸¸' : 'ç”Ÿæˆç‚¹åŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('ç”Ÿæˆç‚¹æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        function runAllTests() {
            testManager.clearResults();
            
            const tests = [
                testMapCreation,
                testTileOperations,
                testCollisionDetection,
                testTileDestruction,
                testMapManager,
                testSpawnPoints
            ];
            
            let passedCount = 0;
            tests.forEach(test => {
                if (test()) passedCount++;
            });
            
            const allPassed = passedCount === tests.length;
            testManager.addResult('æ€»ä½“æµ‹è¯•ç»“æœ', allPassed,
                `${passedCount}/${tests.length} ä¸ªæµ‹è¯•é€šè¿‡`);
            
            console.log(`ğŸ—ºï¸ åœ°å›¾ç³»ç»Ÿæµ‹è¯•å®Œæˆ: ${passedCount}/${tests.length} é€šè¿‡`);
        }

        // æ¸…é™¤ç»“æœ
        function clearResults() {
            testManager.clearResults();
        }

        // åŠ è½½åœ°å›¾
        function loadMap(mapName) {
            testManager.currentMap = testManager.mapManager.loadMap(mapName);
            testManager.renderMap();
            console.log('ğŸ—ºï¸ åŠ è½½åœ°å›¾:', mapName);
        }

        // åˆ›å»ºéšæœºåœ°å›¾
        function createRandomMap() {
            const map = new MapSystem.GameMap(26, 26, 32);
            
            // æ·»åŠ è¾¹æ¡†
            map.drawBorder(MapSystem.TileType.STEEL);
            
            // éšæœºæ·»åŠ éšœç¢ç‰©
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * (map.width - 4)) + 2;
                const y = Math.floor(Math.random() * (map.height - 4)) + 2;
                const tileType = Math.random() > 0.7 ? MapSystem.TileType.STEEL : MapSystem.TileType.BRICK;
                map.setTile(x, y, tileType);
            }
            
            // æ·»åŠ æ°´åŸŸ
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * (map.width - 6)) + 3;
                const y = Math.floor(Math.random() * (map.height - 6)) + 3;
                map.fillArea(x, y, x + 1, y + 1, MapSystem.TileType.WATER);
            }
            
            // æ·»åŠ è‰åœ°
            for (let i = 0; i < 15; i++) {
                const x = Math.floor(Math.random() * (map.width - 4)) + 2;
                const y = Math.floor(Math.random() * (map.height - 4)) + 2;
                map.setTile(x, y, MapSystem.TileType.GRASS);
            }
            
            // æ·»åŠ ç”Ÿæˆç‚¹
            map.setTile(1, map.height - 2, MapSystem.TileType.SPAWN_PLAYER);
            map.setTile(2, map.height - 2, MapSystem.TileType.SPAWN_PLAYER);
            map.setTile(map.width - 2, 1, MapSystem.TileType.SPAWN_ENEMY);
            map.setTile(map.width - 3, 1, MapSystem.TileType.SPAWN_ENEMY);
            
            // æ·»åŠ åŸºåœ°
            map.setTile(Math.floor(map.width / 2), map.height - 2, MapSystem.TileType.BASE);
            
            testManager.currentMap = map;
            testManager.renderMap();
            console.log('ğŸ² åˆ›å»ºéšæœºåœ°å›¾');
        }

        // æ¸…ç©ºåœ°å›¾
        function clearMap() {
            if (testManager.currentMap) {
                testManager.currentMap.clear();
                testManager.renderMap();
                console.log('ğŸ§¹ æ¸…ç©ºåœ°å›¾');
            }
        }

        // æµ‹è¯•ç¢°æ’
        function testCollision() {
            if (!testManager.currentMap) {
                alert('è¯·å…ˆåŠ è½½åœ°å›¾');
                return;
            }
            
            testManager.testPoints = [];
            
            // åœ¨åœ°å›¾ä¸Šéšæœºæµ‹è¯•ä¸€äº›ç‚¹
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * testManager.currentMap.pixelWidth;
                const y = Math.random() * testManager.currentMap.pixelHeight;
                
                if (!testManager.currentMap.isPassable(x, y)) {
                    testManager.testPoints.push({ x, y });
                }
            }
            
            testManager.renderMap();
            console.log('ğŸ’¥ ç¢°æ’æµ‹è¯•å®Œæˆï¼Œç´«è‰²ç‚¹è¡¨ç¤ºä¸å¯é€šè¿‡çš„ä½ç½®');
        }

        // æµ‹è¯•ç ´å
        function testDestruction() {
            if (!testManager.currentMap) {
                alert('è¯·å…ˆåŠ è½½åœ°å›¾');
                return;
            }
            
            // éšæœºç ´åä¸€äº›ç“¦ç‰‡
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * testManager.currentMap.pixelWidth;
                const y = Math.random() * testManager.currentMap.pixelHeight;
                testManager.currentMap.destroyTile(x, y);
            }
            
            testManager.renderMap();
            console.log('ğŸ’£ ç ´åæµ‹è¯•å®Œæˆ');
        }

        // æ˜¾ç¤ºç”Ÿæˆç‚¹
        function showSpawnPoints() {
            testManager.showingSpawns = !testManager.showingSpawns;
            testManager.renderMap();
            console.log('ğŸ“ ç”Ÿæˆç‚¹æ˜¾ç¤º:', testManager.showingSpawns ? 'å¼€å¯' : 'å…³é—­');
        }
    </script>
</body>
</html>