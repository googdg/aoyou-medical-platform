<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¦å…‹ç³»ç»Ÿæµ‹è¯• - Tank System Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        #tankCanvas {
            border: 2px solid #333;
            background: #000;
        }
        .controls {
            margin: 10px 0;
        }
        .tank-info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .tank-types {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .tank-sample {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .tank-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>ğŸš— å¦å…‹ç³»ç»Ÿæµ‹è¯•</h1>
    
    <div class="test-container">
        <h2>ğŸ“‹ æµ‹è¯•ç»“æœ</h2>
        <div id="testResults"></div>
        <button onclick="runAllTests()">ğŸš€ è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
        <button onclick="clearResults()">ğŸ§¹ æ¸…é™¤ç»“æœ</button>
    </div>

    <div class="test-container">
        <h2>ğŸ® å¦å…‹å¯è§†åŒ–æµ‹è¯•</h2>
        <canvas id="tankCanvas" width="800" height="600"></canvas>
        <div class="controls">
            <button onclick="createPlayerTank()">ğŸš— åˆ›å»ºç©å®¶å¦å…‹</button>
            <button onclick="createEnemyTank('basic')">ğŸ¤– åŸºç¡€æ•Œå¦å…‹</button>
            <button onclick="createEnemyTank('fast')">âš¡ å¿«é€Ÿæ•Œå¦å…‹</button>
            <button onclick="createEnemyTank('heavy')">ğŸ›¡ï¸ é‡å‹æ•Œå¦å…‹</button>
            <button onclick="clearTanks()">ğŸ§¹ æ¸…é™¤å¦å…‹</button>
        </div>
        <div class="controls">
            <button onclick="testMovement()">ğŸƒ æµ‹è¯•ç§»åŠ¨</button>
            <button onclick="testFiring()">ğŸ’¥ æµ‹è¯•å°„å‡»</button>
            <button onclick="testCollision()">ğŸ’¥ æµ‹è¯•ç¢°æ’</button>
            <button onclick="testDamage()">ğŸ©¸ æµ‹è¯•ä¼¤å®³</button>
        </div>
        <div class="controls">
            <p><strong>æ§åˆ¶è¯´æ˜ï¼š</strong> WASDç§»åŠ¨ç¬¬ä¸€ä¸ªå¦å…‹ï¼Œç©ºæ ¼å°„å‡»</p>
        </div>
    </div>

    <div class="test-container">
        <h2>ğŸ“Š å¦å…‹ä¿¡æ¯</h2>
        <div class="tank-info" id="tankInfo">
            <p>å¦å…‹æ•°é‡: <span id="tankCount">0</span></p>
            <p>å­å¼¹æ•°é‡: <span id="bulletCount">0</span></p>
        </div>
        
        <h3>å¦å…‹ç±»å‹</h3>
        <div class="tank-types">
            <div class="tank-sample">
                <div class="tank-color" style="background: #4CAF50;"></div>
                <span>ç©å®¶å¦å…‹</span>
            </div>
            <div class="tank-sample">
                <div class="tank-color" style="background: #FF5722;"></div>
                <span>åŸºç¡€æ•Œå¦å…‹</span>
            </div>
            <div class="tank-sample">
                <div class="tank-color" style="background: #E91E63;"></div>
                <span>å¿«é€Ÿæ•Œå¦å…‹</span>
            </div>
            <div class="tank-sample">
                <div class="tank-color" style="background: #795548;"></div>
                <span>é‡å‹æ•Œå¦å…‹</span>
            </div>
            <div class="tank-sample">
                <div class="tank-color" style="background: #9C27B0;"></div>
                <span>ç‰¹æ®Šæ•Œå¦å…‹</span>
            </div>
        </div>
    </div>

    <!-- å¼•å…¥ä¾èµ– -->
    <script src="../js/entity-component-system.js"></script>
    <script src="../js/map-system.js"></script>
    <script src="../js/tank-system.js"></script>
    
    <script>
        // æµ‹è¯•ç®¡ç†å™¨
        class TankTestManager {
            constructor() {
                this.results = [];
                this.entityManager = new ECS.EntityManager();
                this.tankManager = new TankSystem.TankManager(this.entityManager);
                this.canvas = document.getElementById('tankCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                // æ¨¡æ‹Ÿè¾“å…¥ç®¡ç†å™¨
                this.inputManager = {
                    keys: {},
                    isKeyDown: (key) => !!this.keys[key],
                    isKeyPressed: (key) => !!this.keys[key]
                };
                
                // è®¾ç½®å…¨å±€å¼•ç”¨
                window.game = {
                    inputManager: this.inputManager,
                    currentMap: null,
                    createBullet: (bulletData) => this.createBullet(bulletData),
                    onPlayerTankDestroyed: () => console.log('ç©å®¶å¦å…‹è¢«æ‘§æ¯'),
                    onEnemyTankDestroyed: () => console.log('æ•Œæ–¹å¦å…‹è¢«æ‘§æ¯')
                };
                
                this.initInput();
                this.startRenderLoop();
            }

            initInput() {
                document.addEventListener('keydown', (e) => {
                    this.inputManager.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.inputManager.keys[e.code] = false;
                });
            }

            // åˆ›å»ºå­å¼¹
            createBullet(bulletData) {
                const bullet = new ECS.Entity('Bullet');
                
                bullet.addComponent(new ECS.Transform(bulletData.x, bulletData.y, 0));
                bullet.addComponent(new ECS.Renderer(null, 4, 4, '#FFD700'));
                bullet.addComponent(new ECS.Collider(4, 4));
                
                const movement = new ECS.Movement(bulletData.bulletSpeed || 300);
                movement.setVelocity(bulletData.velocityX, bulletData.velocityY);
                bullet.addComponent(movement);
                
                bullet.addTag('bullet');
                bullet.damage = bulletData.damage || 1;
                bullet.owner = bulletData.owner;
                
                this.entityManager.addEntity(bullet);
                
                // ç®€å•çš„ç”Ÿå‘½å‘¨æœŸ
                setTimeout(() => {
                    this.entityManager.removeEntity(bullet);
                }, 2000);
                
                return bullet;
            }

            // æ·»åŠ æµ‹è¯•ç»“æœ
            addResult(testName, passed, message = '') {
                this.results.push({
                    name: testName,
                    passed: passed,
                    message: message,
                    timestamp: new Date().toLocaleTimeString()
                });
                this.updateResultsDisplay();
            }

            // æ›´æ–°ç»“æœæ˜¾ç¤º
            updateResultsDisplay() {
                const container = document.getElementById('testResults');
                container.innerHTML = '';
                
                this.results.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                    div.innerHTML = `
                        <strong>${result.passed ? 'âœ…' : 'âŒ'} ${result.name}</strong>
                        <br><small>${result.timestamp}</small>
                        ${result.message ? `<br>${result.message}` : ''}
                    `;
                    container.appendChild(div);
                });
            }

            // æ¸…é™¤ç»“æœ
            clearResults() {
                this.results = [];
                this.updateResultsDisplay();
            }

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            startRenderLoop() {
                const render = () => {
                    this.update();
                    this.render();
                    this.updateInfo();
                    requestAnimationFrame(render);
                };
                render();
            }

            // æ›´æ–°
            update() {
                this.entityManager.update(16);
            }

            // æ¸²æŸ“
            render() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#222';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶ç½‘æ ¼
                this.drawGrid();
                
                // æ¸²æŸ“æ‰€æœ‰å®ä½“
                this.entityManager.render(this.ctx);
            }

            // ç»˜åˆ¶ç½‘æ ¼
            drawGrid() {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            updateInfo() {
                const tanks = this.entityManager.getEntitiesByTag('tank');
                const bullets = this.entityManager.getEntitiesByTag('bullet');
                
                document.getElementById('tankCount').textContent = tanks.length;
                document.getElementById('bulletCount').textContent = bullets.length;
            }
        }

        // å…¨å±€æµ‹è¯•ç®¡ç†å™¨
        let testManager;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            testManager = new TankTestManager();
            console.log('ğŸš— å¦å…‹æµ‹è¯•ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
        });

        // æµ‹è¯•å‡½æ•°
        function testTankCreation() {
            try {
                const tank = TankSystem.TankFactory.createPlayerTank(100, 100, 1);
                
                const hasTransform = tank.hasComponent('Transform');
                const hasController = tank.hasComponent('TankController');
                const hasRenderer = tank.hasComponent('TankRenderer');
                const hasWeapon = tank.hasComponent('Weapon');
                const hasHealth = tank.hasComponent('Health');
                
                const passed = hasTransform && hasController && hasRenderer && hasWeapon && hasHealth;
                testManager.addResult('å¦å…‹åˆ›å»ºæµ‹è¯•', passed, 
                    passed ? 'å¦å…‹ç»„ä»¶åˆ›å»ºå®Œæ•´' : 'å¦å…‹ç»„ä»¶ç¼ºå¤±');
                return passed;
            } catch (error) {
                testManager.addResult('å¦å…‹åˆ›å»ºæµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTankController() {
            try {
                const controller = new TankSystem.TankController(TankSystem.TankType.PLAYER, 1);
                
                const hasControls = controller.controls !== null;
                const correctType = controller.tankType === TankSystem.TankType.PLAYER;
                const correctPlayer = controller.playerId === 1;
                
                const passed = hasControls && correctType && correctPlayer;
                testManager.addResult('å¦å…‹æ§åˆ¶å™¨æµ‹è¯•', passed,
                    passed ? 'æ§åˆ¶å™¨é…ç½®æ­£ç¡®' : 'æ§åˆ¶å™¨é…ç½®é”™è¯¯');
                return passed;
            } catch (error) {
                testManager.addResult('å¦å…‹æ§åˆ¶å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTankRenderer() {
            try {
                const renderer = new TankSystem.TankRenderer(TankSystem.TankType.PLAYER);
                
                const hasConfig = renderer.config !== null;
                const correctColor = renderer.config.color === '#4CAF50';
                const correctSize = renderer.width === 30;
                
                const passed = hasConfig && correctColor && correctSize;
                testManager.addResult('å¦å…‹æ¸²æŸ“å™¨æµ‹è¯•', passed,
                    passed ? 'æ¸²æŸ“å™¨é…ç½®æ­£ç¡®' : 'æ¸²æŸ“å™¨é…ç½®é”™è¯¯');
                return passed;
            } catch (error) {
                testManager.addResult('å¦å…‹æ¸²æŸ“å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTankTypes() {
            try {
                const types = [
                    TankSystem.TankType.PLAYER,
                    TankSystem.TankType.ENEMY_BASIC,
                    TankSystem.TankType.ENEMY_FAST,
                    TankSystem.TankType.ENEMY_HEAVY
                ];
                
                let allConfigsExist = true;
                for (const type of types) {
                    if (!TankSystem.TankConfig[type]) {
                        allConfigsExist = false;
                        break;
                    }
                }
                
                const passed = allConfigsExist && types.length === 4;
                testManager.addResult('å¦å…‹ç±»å‹æµ‹è¯•', passed,
                    passed ? 'æ‰€æœ‰å¦å…‹ç±»å‹é…ç½®å®Œæ•´' : 'å¦å…‹ç±»å‹é…ç½®ç¼ºå¤±');
                return passed;
            } catch (error) {
                testManager.addResult('å¦å…‹ç±»å‹æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTankManager() {
            try {
                const entityManager = new ECS.EntityManager();
                const tankManager = new TankSystem.TankManager(entityManager);
                
                const playerTank = tankManager.createPlayerTank(100, 100, 1);
                const enemyTank = tankManager.createEnemyTank(200, 200);
                
                entityManager.update(16); // å¤„ç†å¾…æ·»åŠ çš„å®ä½“
                
                const stats = tankManager.getStats();
                const correctStats = stats.totalPlayers === 1 && stats.totalEnemies === 1;
                
                const passed = playerTank && enemyTank && correctStats;
                testManager.addResult('å¦å…‹ç®¡ç†å™¨æµ‹è¯•', passed,
                    passed ? 'å¦å…‹ç®¡ç†å™¨åŠŸèƒ½æ­£å¸¸' : 'å¦å…‹ç®¡ç†å™¨åŠŸèƒ½å¼‚å¸¸');
                return passed;
            } catch (error) {
                testManager.addResult('å¦å…‹ç®¡ç†å™¨æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        function testTankDirection() {
            try {
                const directions = [
                    TankSystem.TankDirection.UP,
                    TankSystem.TankDirection.RIGHT,
                    TankSystem.TankDirection.DOWN,
                    TankSystem.TankDirection.LEFT
                ];
                
                const correctValues = directions[0] === 0 && 
                                    directions[1] === 90 && 
                                    directions[2] === 180 && 
                                    directions[3] === 270;
                
                const passed = correctValues;
                testManager.addResult('å¦å…‹æ–¹å‘æµ‹è¯•', passed,
                    passed ? 'å¦å…‹æ–¹å‘æšä¸¾æ­£ç¡®' : 'å¦å…‹æ–¹å‘æšä¸¾é”™è¯¯');
                return passed;
            } catch (error) {
                testManager.addResult('å¦å…‹æ–¹å‘æµ‹è¯•', false, `é”™è¯¯: ${error.message}`);
                return false;
            }
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        function runAllTests() {
            testManager.clearResults();
            
            const tests = [
                testTankCreation,
                testTankController,
                testTankRenderer,
                testTankTypes,
                testTankManager,
                testTankDirection
            ];
            
            let passedCount = 0;
            tests.forEach(test => {
                if (test()) passedCount++;
            });
            
            const allPassed = passedCount === tests.length;
            testManager.addResult('æ€»ä½“æµ‹è¯•ç»“æœ', allPassed,
                `${passedCount}/${tests.length} ä¸ªæµ‹è¯•é€šè¿‡`);
            
            console.log(`ğŸš— å¦å…‹ç³»ç»Ÿæµ‹è¯•å®Œæˆ: ${passedCount}/${tests.length} é€šè¿‡`);
        }

        // æ¸…é™¤ç»“æœ
        function clearResults() {
            testManager.clearResults();
        }

        // åˆ›å»ºç©å®¶å¦å…‹
        function createPlayerTank() {
            const x = Math.random() * (testManager.canvas.width - 100) + 50;
            const y = Math.random() * (testManager.canvas.height - 100) + 50;
            testManager.tankManager.createPlayerTank(x, y, 1);
            console.log('ğŸš— åˆ›å»ºç©å®¶å¦å…‹');
        }

        // åˆ›å»ºæ•Œæ–¹å¦å…‹
        function createEnemyTank(type) {
            const x = Math.random() * (testManager.canvas.width - 100) + 50;
            const y = Math.random() * (testManager.canvas.height - 100) + 50;
            
            let tankType;
            switch(type) {
                case 'basic': tankType = TankSystem.TankType.ENEMY_BASIC; break;
                case 'fast': tankType = TankSystem.TankType.ENEMY_FAST; break;
                case 'heavy': tankType = TankSystem.TankType.ENEMY_HEAVY; break;
                default: tankType = TankSystem.TankType.ENEMY_BASIC;
            }
            
            testManager.tankManager.createEnemyTank(x, y, tankType);
            console.log('ğŸ¤– åˆ›å»ºæ•Œæ–¹å¦å…‹:', type);
        }

        // æ¸…é™¤å¦å…‹
        function clearTanks() {
            testManager.tankManager.clearAll();
            console.log('ğŸ§¹ æ¸…é™¤æ‰€æœ‰å¦å…‹');
        }

        // æµ‹è¯•ç§»åŠ¨
        function testMovement() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºå¦å…‹');
                return;
            }
            
            // ç»™ç¬¬ä¸€ä¸ªå¦å…‹æ·»åŠ éšæœºç§»åŠ¨
            const tank = tanks[0];
            const controller = tank.getComponent('TankController');
            if (controller) {
                // æ¨¡æ‹ŸæŒ‰é”®
                const directions = ['KeyW', 'KeyS', 'KeyA', 'KeyD'];
                const randomDir = directions[Math.floor(Math.random() * directions.length)];
                testManager.inputManager.keys[randomDir] = true;
                
                setTimeout(() => {
                    testManager.inputManager.keys[randomDir] = false;
                }, 1000);
            }
            
            console.log('ğŸƒ æµ‹è¯•å¦å…‹ç§»åŠ¨');
        }

        // æµ‹è¯•å°„å‡»
        function testFiring() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºå¦å…‹');
                return;
            }
            
            // è®©æ‰€æœ‰å¦å…‹å°„å‡»
            tanks.forEach(tank => {
                const weapon = tank.getComponent('Weapon');
                if (weapon && weapon.tryFire()) {
                    const bulletData = weapon.createBulletData();
                    if (bulletData) {
                        testManager.createBullet(bulletData);
                    }
                }
            });
            
            console.log('ğŸ’¥ æµ‹è¯•å¦å…‹å°„å‡»');
        }

        // æµ‹è¯•ç¢°æ’
        function testCollision() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length < 2) {
                alert('éœ€è¦è‡³å°‘2ä¸ªå¦å…‹æ¥æµ‹è¯•ç¢°æ’');
                return;
            }
            
            // å°†ä¸¤ä¸ªå¦å…‹ç§»åŠ¨åˆ°ç›¸è¿‘ä½ç½®
            const tank1 = tanks[0];
            const tank2 = tanks[1];
            
            const transform1 = tank1.getComponent('Transform');
            const transform2 = tank2.getComponent('Transform');
            
            if (transform1 && transform2) {
                transform2.setPosition(transform1.x + 20, transform1.y + 20);
                console.log('ğŸ’¥ å¼ºåˆ¶å¦å…‹ç¢°æ’æµ‹è¯•');
            }
        }

        // æµ‹è¯•ä¼¤å®³
        function testDamage() {
            const tanks = testManager.entityManager.getEntitiesByTag('tank');
            if (tanks.length === 0) {
                alert('è¯·å…ˆåˆ›å»ºå¦å…‹');
                return;
            }
            
            // å¯¹ç¬¬ä¸€ä¸ªå¦å…‹é€ æˆä¼¤å®³
            const tank = tanks[0];
            const health = tank.getComponent('Health');
            if (health) {
                health.takeDamage(1);
                console.log('ğŸ©¸ å¯¹å¦å…‹é€ æˆä¼¤å®³');
            }
        }
    </script>
</body>
</html>